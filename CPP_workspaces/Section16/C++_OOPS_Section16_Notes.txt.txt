															PolyMorphism & Inheritance
															=============================
															
When we overload a functions and when we overload an operator this comes into picture.
Polymorphism:
=============
-compile time/early binding/static binding----Before the program executes/Somethings that compiler takes care of way before the program runs.
-Run time/late binding/dynamic binding()------Associations what the programmer wants to do during program is running or executes.

Runtime polymorphism:
======================
-Being Able to assign different meanings to the same function at run-time.

Allow us to thing more abstractly:
=======================================
-PolyMorphism allows us to run correct function.
 example: We can run specific version of Deposit, withdrawls and print from classes Account,Deposit_Account,Current_Account at run time using only Account
		  Refernce.
		  
-Let C++ figure out which function to call at run-time.

-In c++ default type of binding is static binding.

-So Run time polymorphism is achieved by:
==============================================
-Inheritance
-Base class pointers and references.
-virtual functions.

PolyMorphism:
==============
Compile time:
---------------
1.Function Overloading.
2.Operator Overloading:

Run time:
----------
Function Overriding.---->Using Inheritance,Base class pointers and references and virtual functions.


example:
===========
An non polymorphic example:(Static Binding)
----------------------------------------------
Account a;
a.withdraw(1000);				//Account::withdraw()


Saving b;
b.withdraw(1000);				//Saving::withdraw()

Checking c;
c.withdraw(1000);				//Checking::withdraw()

Account d;
d.withdraw(1000);				//Trust::withdraw()


Account *p = new Trust();		//Trust is an account so Account *p can hold the address of Trust
p->withdraw(1000);				//Account::withdraw() but it should be Trust::withdraw() but due to static binding the Account::withdraw is called
								  during compile time already.
								  
								  
								  
An non polymorphic example2:(Static Binding)
----------------------------------------------
void display_account(const Account &acc)
{
	acc::display();		//Will always call Account::display() due to static binding/compile time binding/early binding
}

Account a;
display_account(a);

Saving b;
display_account(b);

Checking c;
display_account(c);

Trust d;
display_account(d);
 


A polymorphic example:(Run time binding/Dynamic Binding/late binding)
-------------------------------------------------------------------
//withdraw method is virtual in Account.

Account a;
a.withdraw(1000);				//Account::withdraw()


Saving b;
b.withdraw(1000);				//Saving::withdraw()

Checking c;
c.withdraw(1000);				//Checking::withdraw()

Account d;
d.withdraw(1000);				//Trust::withdraw()


Account *p = new Trust();		//Trust is an account so Account *p can hold the address of Trust
p->withdraw(1000);				//Trust::withdraw() but due to late binding/Dynamic Binding. To make the runtime binding withdarw method is assigned a
									keyword virtual
									
									
A polymorphic example2:(Run time binding/Dynamic Binding/late binding)
-------------------------------------------------------------------		
//display() method is defined as virtual to avoid static binding/compile time binding and make it as bind at run time.
							
void display_account(const Account &acc)
{
	acc::display();		//Will always call the display() method depending upon the object's type at RUN-TIME
}

Account a;
display_account(a);

Saving b;
display_account(b);

Checking c;
display_account(c);

Trust d;
display_account(d);

======================================================================================================================================================
													Using a Base class pointer
													==========================
-For Dynamic polymorphism we must have:
	-Inheritance.
	-Base class pointer and Base class reference.
	-virtual functions
	
	
Example:
=============
Account *p1 = new Account();
Account *p2 = new Saving();
Account *p3 = new Checking();
Account *p4 = new Trust();

//All accounts are using public "IS-A" inheritance

p1->withdraw(1000);		//Account::withdraw()
p2->withdraw(1000);		//Saving::withdraw()
p3->withdraw(1000);		//Checking::withdraw()
p4->withdraw(1000);		//Trust::withdraw()

Account *array [] = {p1,p2,p3,p4};

for(auto i=0; i<4; i++)
	array[i]->withdraw(1000);
	
	
Vector<Account *> vec_arr {p1,p2,p3,p4};
for(auto acc_ptr:accounts)
{
	acc_ptr->withdraw(1000);
}

=======================================================================================================================================================
														Virtual Functions
														=================
-Redefined functions in the Derived class and Base class bound statically.
-Overriden functions are bound dynamically. We do this by declaring the function to virtual.
-Virtual functions are overriden.
-Allow us to treat all objects generally as objects of the base class.


Declaring virtual functions:
=================================
-Declare the function you want to make as virtual in the base class.
-Virtual functions are virtual all the way down the hirerachy down this point.
-Dynamic polymorphism only via Account class pointer or refernce.

class Account{
	virtual void withdraw(double amount);
	. . .
};

-In the Account Base class we have declared the withdarw method as virtual with virtual keyword.
-withdraw is a virtual function which means it can be overriden in the derived classes and it will bind dynamically at run time when we use base class
 pointer or refernce.
 
 
-Override the function in the Derived classes.
-Function sugnature and return type must match exactly. If you don't do it compiler treats as redefinition and statically bind the method.
-virtual keyword is not required but is best practice.
-if you don't provide and overridden version it is inherited from it's base class.


class Checking : public Account{
	virtual void withdarw(double amount);
	....
};

========================================================================================================================================================
													Virtual Destructors:
													====================
-If a derived class is destroyed by deleting its storage via the base class pointer and the class is a non virtual destructor. then behaviour is undefined
 in the c++ standard.
-Derived objects must be destoyed in the right order starting at the correct destructor.

Solution:
==========
-If a class has a virtual functions.
-Always provide a public virtual destructor.
-If base class destructor is virtual then all derived class destructors are also virtual.

class Account{
	virtual void withdraw(double amount);
	virtual ~Account();
	. . .
};

example:
============
without virtual Destructor:
============================
#include <iostream>
#include <vector>
class Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Account(){std::cout <<"Account:: Destructor" << std::endl;}
};

class Saving_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Saving_Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Saving_Account(){std::cout <<"Saving_Account:: Destructor" << std::endl;}
};

class Checking_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Checking_Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Checking_Account(){std::cout <<"Checking_Account:: Destructor" << std::endl;}
};

class Trust_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Trust_Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Trust_Account(){std::cout <<"Trust_Account:: Destructor" << std::endl;}
};

int main()
{
	Account *p1 = new Account();
    Account *p2 = new Saving_Account();
    Account *p3 = new Checking_Account();
    Account *p4 = new Trust_Account();
    
    std::cout << "\n===========Pointers==========" << std::endl;
    p1->withdraw(1000);
    p2->withdraw(1000);
    p3->withdraw(1000);
    p4->withdraw(1000);
    
    std::cout << "\n===========Array==========" << std::endl;
    Account *account [] = {p1,p2,p3,p4};
    
    for(auto i=0 ; i<4; i++)
        account[i]->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;
    std::vector <Account *> acc_vec {p1,p2,p3,p4};
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;    
    acc_vec.push_back(p4);
    acc_vec.push_back(p4);
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
        
    std::cout << "\n==========Deleting===========" << std::endl; 
    delete p1;
    delete p2;
    delete p3;
    delete p4;
    
	return 0;
}

Compilation Warning:
========================
C:\WINDOWS\system32\cmd.exe /C ""C:/Program Files/mingw-w64/mingw64/bin/mingw32-make.exe" -j8 SHELL=cmd.exe -e -f  Makefile"
"----------Building project:[ 04_VirtualDestructors - Debug ]----------"
mingw32-make.exe[1]: Entering directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors'
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe"  -c  "D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp" -g -O0 -std=c++17 -Wall  -o Debug/main.cpp.o -I. -I.
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp: In function 'int main()':
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:71:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p1;
            ^~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:72:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p2;
            ^~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:73:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p3;
            ^~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:74:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p4;
            ^~
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe" -o Debug/04_VirtualDestructors @"04_VirtualDestructors.txt" -L.   -static
mingw32-make.exe[1]: Leaving directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors'
====0 errors, 4 warnings====


op:
=====
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

===========Array==========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Deleting===========
Account:: Destructor
Account:: Destructor
Account:: Destructor
Account:: Destructor





with virtual destructor:
===========================
#include <iostream>
#include <vector>
class Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Account class:" << __func__ << ":" << balance << std::endl;
    }
   virtual ~Account(){std::cout <<"Account:: Destructor" << std::endl;}
};

class Saving_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Saving_Account class:" << __func__ << ":" << balance << std::endl;
    }
    virtual ~Saving_Account(){std::cout <<"Saving_Account:: Destructor" << std::endl;}
};

class Checking_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Checking_Account class:" << __func__ << ":" << balance << std::endl;
    }
    virtual ~Checking_Account(){std::cout <<"Checking_Account:: Destructor" << std::endl;}
};

class Trust_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Trust_Account class:" << __func__ << ":" << balance << std::endl;
    }
    virtual ~Trust_Account(){std::cout <<"Trust_Account:: Destructor" << std::endl;}
};

int main()
{
	Account *p1 = new Account();
    Account *p2 = new Saving_Account();
    Account *p3 = new Checking_Account();
    Account *p4 = new Trust_Account();
    
    std::cout << "\n===========Pointers==========" << std::endl;
    p1->withdraw(1000);
    p2->withdraw(1000);
    p3->withdraw(1000);
    p4->withdraw(1000);
    
    std::cout << "\n===========Array==========" << std::endl;
    Account *account [] = {p1,p2,p3,p4};
    
    for(auto i=0 ; i<4; i++)
        account[i]->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;
    std::vector <Account *> acc_vec {p1,p2,p3,p4};
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;    
    acc_vec.push_back(p4);
    acc_vec.push_back(p4);
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
        
    std::cout << "\n==========Deleting===========" << std::endl; 
    delete p1;
    delete p2;
    delete p3;
    delete p4;
    
	return 0;
}

op:
======
===========Array==========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Deleting===========
Account:: Destructor
Saving_Account:: Destructor
Account:: Destructor
Checking_Account:: Destructor
Account:: Destructor
Trust_Account:: Destructor
Account:: Destructor

========================================================================================================================================================
														Using Override keyword
														==========================
The override specifier:
=======================
-We can override Base class virtual functions
-The function signature and return must be EXACTLY the same.
-If they are different then we have redefinition not overriding.
-Redefinition is statically bound.
-Overriding is dynamically bound.
-C++11 provides an override specifier to have the compiler ensure overriding.

example:
----------
#include <iostream>

class Base{
public:
    virtual void say_hello() const{
        std::cout << "Base::" << __func__ << " is called" << std::endl;
    }
    virtual ~Base() {std::cout<< __func__ << std::endl;}
};
class Derived : public Base{
public:
    virtual void say_hello() {  //Forget the const so not overriding
        std::cout << "Derived::" << __func__ << " is called" << std::endl;
    }
    virtual ~Derived()  {std::cout<< __func__ << std::endl;}
};

int main()
{
	Base *b = new Base();
    b->say_hello();
    
    Derived *d = new Derived();
    d->say_hello();
    
    Base *derived =  new Derived();
    derived->say_hello();
    
    delete b;
    delete d;
    delete derived;
	return 0;
}
op:
======
Base::say_hello is called
Derived::say_hello is called
Base::say_hello is called
~Base
~Derived
~Base
~Derived
~Base

-say_hello() method signatures are different in both base and derived class.
-So Derived redefines say_hello() instead of overriding it.

override specifier example:
==============================
#include <iostream>

class Base{
public:
    virtual void say_hello() const{
        std::cout << "Base::" << __func__ << " is called" << std::endl;
    }
    virtual ~Base() {std::cout<< __func__ << std::endl;}
};
class Derived : public Base{
public:
    virtual void say_hello() override{  //Forget the const so not overriding
        std::cout << "Derived::" << __func__ << " is called" << std::endl;
    }
    virtual ~Derived()  {std::cout<< __func__ << std::endl;}
};

int main()
{
	Base *b = new Base();
    b->say_hello();
    
    Derived *d = new Derived();
    d->say_hello();
    
    Base *derived =  new Derived();
    derived->say_hello();
    
    delete b;
    delete d;
    delete derived;
	return 0;
}

compilation error:
==================
C:\WINDOWS\system32\cmd.exe /C ""C:/Program Files/mingw-w64/mingw64/bin/mingw32-make.exe" -j8 SHELL=cmd.exe -e -f  Makefile"
"----------Building project:[ 05_OverrideSpecifier - Debug ]----------"
mingw32-make.exe[1]: Entering directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier'
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe"  -c  "D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier/main.cpp" -g -O0 -std=c++17 -Wall  -o Debug/main.cpp.o -I. -I.
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier/main.cpp:12:18: error: 'virtual void Derived::say_hello()' marked 'override', but does not override
     virtual void say_hello() override{  //Forget the const so not overriding
                  ^~~~~~~~~
mingw32-make.exe[1]: *** [05_OverrideSpecifier.mk:98: Debug/main.cpp.o] Error 1
mingw32-make.exe: *** [Makefile:5: All] Error 2
mingw32-make.exe[1]: Leaving directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier'
====1 errors, 0 warnings====


modified code with override and const specifier:
==================================================
#include <iostream>

class Base{
public:
    virtual void say_hello() const{
        std::cout << "Base::" << __func__ << " is called" << std::endl;
    }
    virtual ~Base() {std::cout<< __func__ << std::endl;}
};
class Derived : public Base{
public:
    virtual void say_hello() const override{  //Forget the const so not overriding
        std::cout << "Derived::" << __func__ << " is called" << std::endl;
    }
    virtual ~Derived()  {std::cout<< __func__ << std::endl;}
};

int main()
{
	Base *b = new Base();
    b->say_hello();
    
    Derived *d = new Derived();
    d->say_hello();
    
    Base *derived =  new Derived();
    derived->say_hello();
    
    delete b;
    delete d;
    delete derived;
	return 0;
}

op:
====
Base::say_hello is called
Derived::say_hello is called
Derived::say_hello is called
~Base
~Derived
~Base
~Derived
~Base

========================================================================================================================================================
														The final Specifier
														====================
-C++11 provides the final specifier 
	-When used at the class level.
	-Prevent a class from being derived from.
	
	-When used in the method level.
	-Prevents virtual method from being overridden in derived class.
	
Syntax:
=========
final class
-----------
class My_class final{					//My_class can not be derived further
	. . .
};

class Derived final : public Base{		//Derived can not be derived further
	. . .
};

If we try to derive any class from the above class than the compiler will generate compiler error.


final method:
----------------
class A{
public:
	virtual void do_something();
};

class B : public A{
	virtual void do_something() final;		//Prevent further overriding
};

class C : public B{
	virtual void do_something();			//Compiler error: Can't do overriding
};
