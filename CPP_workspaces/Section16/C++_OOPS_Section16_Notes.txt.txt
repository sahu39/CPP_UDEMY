															PolyMorphism & Inheritance
															=============================
															
When we overload a functions and when we overload an operator this comes into picture.
Polymorphism:
=============
-compile time/early binding/static binding----Before the program executes/Somethings that compiler takes care of way before the program runs.
-Run time/late binding/dynamic binding()------Associations what the programmer wants to do during program is running or executes.

Runtime polymorphism:
======================
-Being Able to assign different meanings to the same function at run-time.

Allow us to thing more abstractly:
=======================================
-PolyMorphism allows us to run correct function.
 example: We can run specific version of Deposit, withdrawls and print from classes Account,Deposit_Account,Current_Account at run time using only Account
		  Refernce.
		  
-Let C++ figure out which function to call at run-time.

-In c++ default type of binding is static binding.

-So Run time polymorphism is achieved by:
==============================================
-Inheritance
-Base class pointers and references.
-virtual functions.

PolyMorphism:
==============
Compile time:
---------------
1.Function Overloading.
2.Operator Overloading:

Run time:
----------
Function Overriding.---->Using Inheritance,Base class pointers and references and virtual functions.


example:
===========
An non polymorphic example:(Static Binding)
----------------------------------------------
Account a;
a.withdraw(1000);				//Account::withdraw()


Saving b;
b.withdraw(1000);				//Saving::withdraw()

Checking c;
c.withdraw(1000);				//Checking::withdraw()

Account d;
d.withdraw(1000);				//Trust::withdraw()


Account *p = new Trust();		//Trust is an account so Account *p can hold the address of Trust
p->withdraw(1000);				//Account::withdraw() but it should be Trust::withdraw() but due to static binding the Account::withdraw is called
								  during compile time already.
								  
								  
								  
An non polymorphic example2:(Static Binding)
----------------------------------------------
void display_account(const Account &acc)
{
	acc::display();		//Will always call Account::display() due to static binding/compile time binding/early binding
}

Account a;
display_account(a);

Saving b;
display_account(b);

Checking c;
display_account(c);

Trust d;
display_account(d);
 


A polymorphic example:(Run time binding/Dynamic Binding/late binding)
-------------------------------------------------------------------
//withdraw method is virtual in Account.

Account a;
a.withdraw(1000);				//Account::withdraw()


Saving b;
b.withdraw(1000);				//Saving::withdraw()

Checking c;
c.withdraw(1000);				//Checking::withdraw()

Account d;
d.withdraw(1000);				//Trust::withdraw()


Account *p = new Trust();		//Trust is an account so Account *p can hold the address of Trust
p->withdraw(1000);				//Trust::withdraw() but due to late binding/Dynamic Binding. To make the runtime binding withdarw method is assigned a
									keyword virtual
									
									
A polymorphic example2:(Run time binding/Dynamic Binding/late binding)
-------------------------------------------------------------------		
//display() method is defined as virtual to avoid static binding/compile time binding and make it as bind at run time.
							
void display_account(const Account &acc)
{
	acc::display();		//Will always call the display() method depending upon the object's type at RUN-TIME
}

Account a;
display_account(a);

Saving b;
display_account(b);

Checking c;
display_account(c);

Trust d;
display_account(d);

======================================================================================================================================================
													Using a Base class pointer
													==========================
-For Dynamic polymorphism we must have:
	-Inheritance.
	-Base class pointer and Base class reference.
	-virtual functions
	
	
Example:
=============
Account *p1 = new Account();
Account *p2 = new Saving();
Account *p3 = new Checking();
Account *p4 = new Trust();

//All accounts are using public "IS-A" inheritance

p1->withdraw(1000);		//Account::withdraw()
p2->withdraw(1000);		//Saving::withdraw()
p3->withdraw(1000);		//Checking::withdraw()
p4->withdraw(1000);		//Trust::withdraw()

Account *array [] = {p1,p2,p3,p4};

for(auto i=0; i<4; i++)
	array[i]->withdraw(1000);
	
	
Vector<Account *> vec_arr {p1,p2,p3,p4};
for(auto acc_ptr:accounts)
{
	acc_ptr->withdraw(1000);
}

=======================================================================================================================================================
														Virtual Functions
														=================
-Redefined functions in the Derived class and Base class bound statically.
-Overriden functions are bound dynamically. We do this by declaring the function to virtual.
-Virtual functions are overriden.
-Allow us to treat all objects generally as objects of the base class.


Declaring virtual functions:
=================================
-Declare the function you want to make as virtual in the base class.
-Virtual functions are virtual all the way down the hirerachy down this point.
-Dynamic polymorphism only via Account class pointer or refernce.

class Account{
	virtual void withdraw(double amount);
	. . .
};

-In the Account Base class we have declared the withdarw method as virtual with virtual keyword.
-withdraw is a virtual function which means it can be overriden in the derived classes and it will bind dynamically at run time when we use base class
 pointer or refernce.
 
 
-Override the function in the Derived classes.
-Function sugnature and return type must match exactly. If you don't do it compiler treats as redefinition and statically bind the method.
-virtual keyword is not required but is best practice.
-if you don't provide and overridden version it is inherited from it's base class.


class Checking : public Account{
	virtual void withdarw(double amount);
	....
};

