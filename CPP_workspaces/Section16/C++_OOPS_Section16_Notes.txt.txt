															PolyMorphism & Inheritance
															=============================
															
When we overload a functions and when we overload an operator this comes into picture.
Polymorphism:
=============
-compile time/early binding/static binding----Before the program executes/Somethings that compiler takes care of way before the program runs.
-Run time/late binding/dynamic binding()------Associations what the programmer wants to do during program is running or executes.

Runtime polymorphism:
======================
-Being Able to assign different meanings to the same function at run-time.

Allow us to thing more abstractly:
=======================================
-PolyMorphism allows us to run correct function.
 example: We can run specific version of Deposit, withdrawls and print from classes Account,Deposit_Account,Current_Account at run time using only Account
		  Refernce.
		  
-Let C++ figure out which function to call at run-time.

-In c++ default type of binding is static binding.

-So Run time polymorphism is achieved by:
==============================================
-Inheritance
-Base class pointers and references.
-virtual functions.

PolyMorphism:
==============
Compile time:
---------------
1.Function Overloading.
2.Operator Overloading:

Run time:
----------
Function Overriding.---->Using Inheritance,Base class pointers and references and virtual functions.


example:
===========
An non polymorphic example:(Static Binding)
----------------------------------------------
Account a;
a.withdraw(1000);				//Account::withdraw()


Saving b;
b.withdraw(1000);				//Saving::withdraw()

Checking c;
c.withdraw(1000);				//Checking::withdraw()

Account d;
d.withdraw(1000);				//Trust::withdraw()


Account *p = new Trust();		//Trust is an account so Account *p can hold the address of Trust
p->withdraw(1000);				//Account::withdraw() but it should be Trust::withdraw() but due to static binding the Account::withdraw is called
								  during compile time already.
								  
								  
								  
An non polymorphic example2:(Static Binding)
----------------------------------------------
void display_account(const Account &acc)
{
	acc::display();		//Will always call Account::display() due to static binding/compile time binding/early binding
}

Account a;
display_account(a);

Saving b;
display_account(b);

Checking c;
display_account(c);

Trust d;
display_account(d);
 


A polymorphic example:(Run time binding/Dynamic Binding/late binding)
-------------------------------------------------------------------
//withdraw method is virtual in Account.

Account a;
a.withdraw(1000);				//Account::withdraw()


Saving b;
b.withdraw(1000);				//Saving::withdraw()

Checking c;
c.withdraw(1000);				//Checking::withdraw()

Account d;
d.withdraw(1000);				//Trust::withdraw()


Account *p = new Trust();		//Trust is an account so Account *p can hold the address of Trust
p->withdraw(1000);				//Trust::withdraw() but due to late binding/Dynamic Binding. To make the runtime binding withdarw method is assigned a
									keyword virtual
									
									
A polymorphic example2:(Run time binding/Dynamic Binding/late binding)
-------------------------------------------------------------------		
//display() method is defined as virtual to avoid static binding/compile time binding and make it as bind at run time.
							
void display_account(const Account &acc)
{
	acc::display();		//Will always call the display() method depending upon the object's type at RUN-TIME
}

Account a;
display_account(a);

Saving b;
display_account(b);

Checking c;
display_account(c);

Trust d;
display_account(d);

======================================================================================================================================================
													Using a Base class pointer
													==========================
-For Dynamic polymorphism we must have:
	-Inheritance.
	-Base class pointer and Base class reference.
	-virtual functions
	
	
Example:
=============
Account *p1 = new Account();
Account *p2 = new Saving();
Account *p3 = new Checking();
Account *p4 = new Trust();

//All accounts are using public "IS-A" inheritance

p1->withdraw(1000);		//Account::withdraw()
p2->withdraw(1000);		//Saving::withdraw()
p3->withdraw(1000);		//Checking::withdraw()
p4->withdraw(1000);		//Trust::withdraw()

Account *array [] = {p1,p2,p3,p4};

for(auto i=0; i<4; i++)
	array[i]->withdraw(1000);
	
	
Vector<Account *> vec_arr {p1,p2,p3,p4};
for(auto acc_ptr:accounts)
{
	acc_ptr->withdraw(1000);
}

=======================================================================================================================================================
														Virtual Functions
														=================
-Redefined functions in the Derived class and Base class bound statically.
-Overriden functions are bound dynamically. We do this by declaring the function to virtual.
-Virtual functions are overriden.
-Allow us to treat all objects generally as objects of the base class.


Declaring virtual functions:
=================================
-Declare the function you want to make as virtual in the base class.
-Virtual functions are virtual all the way down the hirerachy down this point.
-Dynamic polymorphism only via Account class pointer or refernce.

class Account{
	virtual void withdraw(double amount);
	. . .
};

-In the Account Base class we have declared the withdarw method as virtual with virtual keyword.
-withdraw is a virtual function which means it can be overriden in the derived classes and it will bind dynamically at run time when we use base class
 pointer or refernce.
 
 
-Override the function in the Derived classes.
-Function sugnature and return type must match exactly. If you don't do it compiler treats as redefinition and statically bind the method.
-virtual keyword is not required but is best practice.
-if you don't provide and overridden version it is inherited from it's base class.


class Checking : public Account{
	virtual void withdarw(double amount);
	....
};

========================================================================================================================================================
													Virtual Destructors:
													====================
-If a derived class is destroyed by deleting its storage via the base class pointer and the class is a non virtual destructor. then behaviour is undefined
 in the c++ standard.
-Derived objects must be destoyed in the right order starting at the correct destructor.

Solution:
==========
-If a class has a virtual functions.
-Always provide a public virtual destructor.
-If base class destructor is virtual then all derived class destructors are also virtual.

class Account{
	virtual void withdraw(double amount);
	virtual ~Account();
	. . .
};

example:
============
without virtual Destructor:
============================
#include <iostream>
#include <vector>
class Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Account(){std::cout <<"Account:: Destructor" << std::endl;}
};

class Saving_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Saving_Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Saving_Account(){std::cout <<"Saving_Account:: Destructor" << std::endl;}
};

class Checking_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Checking_Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Checking_Account(){std::cout <<"Checking_Account:: Destructor" << std::endl;}
};

class Trust_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Trust_Account class:" << __func__ << ":" << balance << std::endl;
    }
    ~Trust_Account(){std::cout <<"Trust_Account:: Destructor" << std::endl;}
};

int main()
{
	Account *p1 = new Account();
    Account *p2 = new Saving_Account();
    Account *p3 = new Checking_Account();
    Account *p4 = new Trust_Account();
    
    std::cout << "\n===========Pointers==========" << std::endl;
    p1->withdraw(1000);
    p2->withdraw(1000);
    p3->withdraw(1000);
    p4->withdraw(1000);
    
    std::cout << "\n===========Array==========" << std::endl;
    Account *account [] = {p1,p2,p3,p4};
    
    for(auto i=0 ; i<4; i++)
        account[i]->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;
    std::vector <Account *> acc_vec {p1,p2,p3,p4};
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;    
    acc_vec.push_back(p4);
    acc_vec.push_back(p4);
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
        
    std::cout << "\n==========Deleting===========" << std::endl; 
    delete p1;
    delete p2;
    delete p3;
    delete p4;
    
	return 0;
}

Compilation Warning:
========================
C:\WINDOWS\system32\cmd.exe /C ""C:/Program Files/mingw-w64/mingw64/bin/mingw32-make.exe" -j8 SHELL=cmd.exe -e -f  Makefile"
"----------Building project:[ 04_VirtualDestructors - Debug ]----------"
mingw32-make.exe[1]: Entering directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors'
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe"  -c  "D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp" -g -O0 -std=c++17 -Wall  -o Debug/main.cpp.o -I. -I.
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp: In function 'int main()':
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:71:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p1;
            ^~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:72:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p2;
            ^~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:73:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p3;
            ^~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors/main.cpp:74:12: warning: deleting object of polymorphic class type 'Account' which has non-virtual destructor might cause undefined behavior [-Wdelete-non-virtual-dtor]
     delete p4;
            ^~
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe" -o Debug/04_VirtualDestructors @"04_VirtualDestructors.txt" -L.   -static
mingw32-make.exe[1]: Leaving directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/04_VirtualDestructors'
====0 errors, 4 warnings====


op:
=====
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

===========Array==========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Deleting===========
Account:: Destructor
Account:: Destructor
Account:: Destructor
Account:: Destructor





with virtual destructor:
===========================
#include <iostream>
#include <vector>
class Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Account class:" << __func__ << ":" << balance << std::endl;
    }
   virtual ~Account(){std::cout <<"Account:: Destructor" << std::endl;}
};

class Saving_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Saving_Account class:" << __func__ << ":" << balance << std::endl;
    }
    virtual ~Saving_Account(){std::cout <<"Saving_Account:: Destructor" << std::endl;}
};

class Checking_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Checking_Account class:" << __func__ << ":" << balance << std::endl;
    }
    virtual ~Checking_Account(){std::cout <<"Checking_Account:: Destructor" << std::endl;}
};

class Trust_Account : public Account{
public:
    virtual void withdraw(double balance)
    {
        std::cout << "Trust_Account class:" << __func__ << ":" << balance << std::endl;
    }
    virtual ~Trust_Account(){std::cout <<"Trust_Account:: Destructor" << std::endl;}
};

int main()
{
	Account *p1 = new Account();
    Account *p2 = new Saving_Account();
    Account *p3 = new Checking_Account();
    Account *p4 = new Trust_Account();
    
    std::cout << "\n===========Pointers==========" << std::endl;
    p1->withdraw(1000);
    p2->withdraw(1000);
    p3->withdraw(1000);
    p4->withdraw(1000);
    
    std::cout << "\n===========Array==========" << std::endl;
    Account *account [] = {p1,p2,p3,p4};
    
    for(auto i=0 ; i<4; i++)
        account[i]->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;
    std::vector <Account *> acc_vec {p1,p2,p3,p4};
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
    std::cout << "\n==========Vetor===========" << std::endl;    
    acc_vec.push_back(p4);
    acc_vec.push_back(p4);
    for(auto acc:acc_vec)
        acc->withdraw(1000);
        
        
    std::cout << "\n==========Deleting===========" << std::endl; 
    delete p1;
    delete p2;
    delete p3;
    delete p4;
    
	return 0;
}

op:
======
===========Array==========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Vetor===========
Account class:withdraw:1000
Saving_Account class:withdraw:1000
Checking_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000
Trust_Account class:withdraw:1000

==========Deleting===========
Account:: Destructor
Saving_Account:: Destructor
Account:: Destructor
Checking_Account:: Destructor
Account:: Destructor
Trust_Account:: Destructor
Account:: Destructor

========================================================================================================================================================
														Using Override keyword
														==========================
The override specifier:
=======================
-We can override Base class virtual functions
-The function signature and return must be EXACTLY the same.
-If they are different then we have redefinition not overriding.
-Redefinition is statically bound.
-Overriding is dynamically bound.
-C++11 provides an override specifier to have the compiler ensure overriding.

example:
----------
#include <iostream>

class Base{
public:
    virtual void say_hello() const{
        std::cout << "Base::" << __func__ << " is called" << std::endl;
    }
    virtual ~Base() {std::cout<< __func__ << std::endl;}
};
class Derived : public Base{
public:
    virtual void say_hello() {  //Forget the const so not overriding
        std::cout << "Derived::" << __func__ << " is called" << std::endl;
    }
    virtual ~Derived()  {std::cout<< __func__ << std::endl;}
};

int main()
{
	Base *b = new Base();
    b->say_hello();
    
    Derived *d = new Derived();
    d->say_hello();
    
    Base *derived =  new Derived();
    derived->say_hello();
    
    delete b;
    delete d;
    delete derived;
	return 0;
}
op:
======
Base::say_hello is called
Derived::say_hello is called
Base::say_hello is called
~Base
~Derived
~Base
~Derived
~Base

-say_hello() method signatures are different in both base and derived class.
-So Derived redefines say_hello() instead of overriding it.

override specifier example:
==============================
#include <iostream>

class Base{
public:
    virtual void say_hello() const{
        std::cout << "Base::" << __func__ << " is called" << std::endl;
    }
    virtual ~Base() {std::cout<< __func__ << std::endl;}
};
class Derived : public Base{
public:
    virtual void say_hello() override{  //Forget the const so not overriding
        std::cout << "Derived::" << __func__ << " is called" << std::endl;
    }
    virtual ~Derived()  {std::cout<< __func__ << std::endl;}
};

int main()
{
	Base *b = new Base();
    b->say_hello();
    
    Derived *d = new Derived();
    d->say_hello();
    
    Base *derived =  new Derived();
    derived->say_hello();
    
    delete b;
    delete d;
    delete derived;
	return 0;
}

compilation error:
==================
C:\WINDOWS\system32\cmd.exe /C ""C:/Program Files/mingw-w64/mingw64/bin/mingw32-make.exe" -j8 SHELL=cmd.exe -e -f  Makefile"
"----------Building project:[ 05_OverrideSpecifier - Debug ]----------"
mingw32-make.exe[1]: Entering directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier'
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe"  -c  "D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier/main.cpp" -g -O0 -std=c++17 -Wall  -o Debug/main.cpp.o -I. -I.
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier/main.cpp:12:18: error: 'virtual void Derived::say_hello()' marked 'override', but does not override
     virtual void say_hello() override{  //Forget the const so not overriding
                  ^~~~~~~~~
mingw32-make.exe[1]: *** [05_OverrideSpecifier.mk:98: Debug/main.cpp.o] Error 1
mingw32-make.exe: *** [Makefile:5: All] Error 2
mingw32-make.exe[1]: Leaving directory 'D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/05_OverrideSpecifier'
====1 errors, 0 warnings====


modified code with override and const specifier:
==================================================
#include <iostream>

class Base{
public:
    virtual void say_hello() const{
        std::cout << "Base::" << __func__ << " is called" << std::endl;
    }
    virtual ~Base() {std::cout<< __func__ << std::endl;}
};
class Derived : public Base{
public:
    virtual void say_hello() const override{  //Forget the const so not overriding
        std::cout << "Derived::" << __func__ << " is called" << std::endl;
    }
    virtual ~Derived()  {std::cout<< __func__ << std::endl;}
};

int main()
{
	Base *b = new Base();
    b->say_hello();
    
    Derived *d = new Derived();
    d->say_hello();
    
    Base *derived =  new Derived();
    derived->say_hello();
    
    delete b;
    delete d;
    delete derived;
	return 0;
}

op:
====
Base::say_hello is called
Derived::say_hello is called
Derived::say_hello is called
~Base
~Derived
~Base
~Derived
~Base

========================================================================================================================================================
														The final Specifier
														====================
-C++11 provides the final specifier 
	-When used at the class level.
	-Prevent a class from being derived from.
	
	-When used in the method level.
	-Prevents virtual method from being overridden in derived class.
	
Syntax:
=========
final class
-----------
class My_class final{					//My_class can not be derived further
	. . .
};

class Derived final : public Base{		//Derived can not be derived further
	. . .
};

If we try to derive any class from the above class than the compiler will generate compiler error.


final method:
----------------
class A{
public:
	virtual void do_something();
};

class B : public A{
	virtual void do_something() final;		//Prevent further overriding
};

class C : public B{
	virtual void do_something();			//Compiler error: Can't do overriding
};
=======================================================================================================================================================
											Using Base class reference for polymorphism
											==============================================
-Useful when we pass object to functions that expect a Base class refernce.

Account a;
Account &ref = a;
ref.withdraw(1000);		//Account::withdarw()

Trust t;
Account &ref = t;
ref1.withdraw(1000);	//Trust::withdraw()



void do_withdraw(Account &account, double amount)
{
	account.withdraw(1000);
}

Account a;
do_withdraw(a,1000);		//Account::withdraw()

Trust t;
do_withdraw(t,1000);		//Trust::withdraw()
=======================================================================================================================================================
												Pure Virtual Function as PolyMorphism
												=====================================
Abstract class:
================
-Cannot instantiate objects.
-These classes are used as base classes in inheritance hirerachies.
-Often refres as abstract base class.

Concrete class:
=============
-Used to instantiate objects from.
-All their members functions are defined.

e.g:
=====
---Account-------------->Abstract Base Class
	Checking_Account---->Concrete class---------------Member functions need to be defined
	Saving_Account------>Concrete class---------------Member functions need to be defined
	
	
---Employee------------->Abstract Base Class
	Faculty------------->Concrete class inherited from Employee---->Member functions need to be defined
	Staff--------------->Concrete class inherited from Employee---->Member functions need to be defined
	
-Abstarct Base Class 
	-To generic to create object from
		e.g:Shape, Empolyee, Account, Player
		
	-Serve as parent to Derived classes that may have objects.
	-Contains at least one pure virtual function.
	
Pure Virtual Function:
=========================
-It is a virtual function used to make a class abstarct.
-Specified with "=0" in its declartion.
-Syntax:						 virtual void function() = 0;	//pure virtual function
-Typically do not provide implementations.


-Derived classes MUST override the base class.
-If Derived class does not override then the derived class is also abstract.
-Concrete class must implement the function which is declared as pure virtual function in the Base class.

	virtual void shape() = 0 ;	//Shape
	virtual void defend() = 0;	//Player
	
example:
===========
class Shape{
private:
	//Attribute from Shape class
public:
	virtual void draw() = 0;		//pure virtual Function
	virtual void rotate() = 0;		//pure virtual function
	virtual ~shape();
	...
};

class Circle : public Shape{
private:
	//Attribute from Shape class
public:
	virtual void draw() override{
		//code to draw a circle
	}		
	virtual void rotate() override{
		//code to rotate a circle
	} 		//pure virtual function
	virtual ~Circle();
	...
};


Shape shape;				//Error
Shape *ptr = new Shape();	//Error

//Using pointers or reference to refer concrete classes derived from them.

Shape *ptr = new Circle();
ptr->draw();
ptr->rotate();


code example:
==============
Example 1:
------------

#include <iostream>
#include <vector>

class Shape{    //Abstract Base Class
private:
    //Abstract Base Class Data;
public:
    virtual void draw() = 0;    //pure virtual function
    virtual void rotate() = 0;  //pure virtual function
    virtual ~Shape(){
        std::cout << "Destroying Shape" << std::endl;
    }

};
class Open_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Open_Shape data
public:
    virtual ~Open_Shape() {}
};

class Close_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Close_Shape data
public:
    virtual ~Close_Shape() {}
};

class Circle : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Circle" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Circle" << std::endl;
    }
    virtual ~Circle()
    {
        std::cout << "Destroying Circle" << std::endl;
    }
};

class Line : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Line" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Line" << std::endl;
    }
    virtual ~Line()
    {
        std::cout << "Destroying Line" << std::endl;
    }
};
int main()
{
    Shape s;
    Shape *p = new Shape();
	return 0;
}

Compilation Error:
=================
C:\WINDOWS\system32\cmd.exe /C ""C:/Program Files/mingw-w64/mingw64/bin/mingw32-make.exe" -j8 SHELL=cmd.exe -e -f  "07_PureVirtualFunction.mk"  MakeIntermediateDirs && "C:/Program Files/mingw-w64/mingw64/bin/mingw32-make.exe" -j8 SHELL=cmd.exe -e -f  "07_PureVirtualFunction.mk"  Debug/main.cpp.o"
----------Building project:[ 07_PureVirtualFunction - Debug ] (Single File Build)----------
"C:/Program Files/mingw-w64/mingw64/bin/g++.exe"  -c  "D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp" -g -O0 -std=c++17 -Wall  -o Debug/main.cpp.o -I. -I.
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp: In function 'int main()':
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp:64:11: error: cannot declare variable 's' to be of abstract type 'Shape'
     Shape s;
           ^
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp:4:7: note:   because the following virtual functions are pure within 'Shape':
 class Shape{    //Abstract Base Class
       ^~~~~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp:8:18: note: 	'virtual void Shape::draw()'
     virtual void draw() = 0;    //pure virtual function
                  ^~~~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp:9:18: note: 	'virtual void Shape::rotate()'
     virtual void rotate() = 0;  //pure virtual function
                  ^~~~~~
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp:65:26: error: invalid new-expression of abstract class type 'Shape'
     Shape *p = new Shape();
                          ^
D:/Studies/CPP_udemy_practice/CPP_workspaces/Section16/07_PureVirtualFunction/main.cpp:65:12: warning: unused variable 'p' [-Wunused-variable]
     Shape *p = new Shape();
            ^
mingw32-make.exe: *** [07_PureVirtualFunction.mk:98: Debug/main.cpp.o] Error 1
====2 errors, 4 warnings====


Example2:
===========
#include <iostream>
#include <vector>

class Shape{    //Abstract Base Class
private:
    //Abstract Base Class Data;
public:
    virtual void draw() = 0;    //pure virtual function
    virtual void rotate() = 0;  //pure virtual function
    virtual ~Shape(){
        std::cout << "Destroying Shape" << std::endl;
    }

};
class Open_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Open_Shape data
public:
    virtual ~Open_Shape() {}
};

class Close_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Close_Shape data
public:
    virtual ~Close_Shape() {}
};

class Circle : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Circle" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Circle" << std::endl;
    }
    virtual ~Circle()
    {
        std::cout << "Destroying Circle" << std::endl;
    }
};

class Line : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Line" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Line" << std::endl;
    }
    virtual ~Line()
    {
        std::cout << "Destroying Line" << std::endl;
    }
};
int main()
{
    //Shape s;
    //Shape *p = new Shape();
    Circle c;
    c.draw();
	return 0;
}

op:
====
Drawing a Circle
Destroying Circle
Destroying Shape
Press any key to continue . . .

Example3:
==============
#include <iostream>
#include <vector>

class Shape{    //Abstract Base Class
private:
    //Abstract Base Class Data;
public:
    virtual void draw() = 0;    //pure virtual function
    virtual void rotate() = 0;  //pure virtual function
    virtual ~Shape(){
        std::cout << "Destroying Shape" << std::endl;
    }

};
class Open_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Open_Shape data
public:
    virtual ~Open_Shape() {}
};

class Close_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Close_Shape data
public:
    virtual ~Close_Shape() {}
};

class Circle : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Circle" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Circle" << std::endl;
    }
    virtual ~Circle()
    {
        std::cout << "Destroying Circle" << std::endl;
    }
};

class Line : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Line" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Line" << std::endl;
    }
    virtual ~Line()
    {
        std::cout << "Destroying Line" << std::endl;
    }
};
int main()
{
    //Shape s;
    //Shape *p = new Shape();
    //Circle c;       
    //c.draw();   //Statically Bound
    
    Shape *ptr = new Circle();
    ptr->draw();    //Dynamically Bound
    ptr->rotate();  //Dynamically Bound
    delete ptr;
	return 0;
}

Op:
=====
Drawing a Circle
Rotateing a Circle
Destroying Circle
Destroying Shape


Example 4:
============
#include <iostream>
#include <vector>

class Shape{    //Abstract Base Class
private:
    //Abstract Base Class Data;
public:
    virtual void draw() = 0;    //pure virtual function
    virtual void rotate() = 0;  //pure virtual function
    virtual ~Shape(){
        std::cout << "Destroying Shape" << std::endl;
    }

};
class Open_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Open_Shape data
public:
    virtual ~Open_Shape() {}
};

class Close_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Close_Shape data
public:
    virtual ~Close_Shape() {}
};

class Circle : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Circle" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Circle" << std::endl;
    }
    virtual ~Circle()
    {
        std::cout << "Destroying Circle" << std::endl;
    }
};

class Line : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Line" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Line" << std::endl;
    }
    virtual ~Line()
    {
        std::cout << "Destroying Line" << std::endl;
    }
};

class Square : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Square" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Square" << std::endl;
    }
    virtual ~Square()
    {
        std::cout << "Destroying Square" << std::endl;
    }
};
int main()
{
    //Shape s;
    //Shape *p = new Shape();
    //Circle c;       
    //c.draw();   //Statically Bound
    
    //Shape *ptr = new Circle();
    //ptr->draw();    //Dynamically Bound
    //ptr->rotate();  //Dynamically Bound
    Shape *s1 = new Line();
    Shape *s2 = new Square();
    Shape *s3 =  new Circle();
    
    std::vector <Shape *> shapes {s1,s2,s3};
    for(const auto s:shapes)
    {
        s->draw();
        s->rotate();
        std::cout << "\n===============\n" << std::endl;
    }
   // delete ptr;
    delete s1;
    delete s2;
    delete s3;
	return 0;
}

op:
======
Drawing a Line
Rotateing a Line

===============

Drawing a Square
Rotateing a Square

===============

Drawing a Circle
Rotateing a Circle

===============

Destroying Line
Destroying Shape
Destroying Square
Destroying Shape
Destroying Circle
Destroying Shape


Example 5:
============
#include <iostream>
#include <vector>

class Shape{    //Abstract Base Class
private:
    //Abstract Base Class Data;
public:
    virtual void draw() = 0;    //pure virtual function
    virtual void rotate() = 0;  //pure virtual function
    virtual ~Shape(){
        std::cout << "Destroying Shape" << std::endl;
    }

};
class Open_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Open_Shape data
public:
    virtual ~Open_Shape() {}
};

class Close_Shape : public Shape{    //Abstarct Class
private:
    //Abstract Close_Shape data
public:
    virtual ~Close_Shape() {}
};

class Circle : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Circle" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Circle" << std::endl;
    }
    virtual ~Circle()
    {
        std::cout << "Destroying Circle" << std::endl;
    }
};

class Line : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Line" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Line" << std::endl;
    }
    virtual ~Line()
    {
        std::cout << "Destroying Line" << std::endl;
    }
};

class Square : public Shape{
private:
    //Circle data
public:
    virtual void draw() override{
        std::cout << "Drawing a Square" << std::endl;
    }
    
    virtual void rotate() override{
        std::cout << "Rotateing a Square" << std::endl;
    }
    virtual ~Square()
    {
        std::cout << "Destroying Square" << std::endl;
    }
};

void screen_refresh(const std::vector<Shape *> &shapes)
{
    for(auto p:shapes)
    {
        p->draw();
        p->rotate();
        std::cout << "\n===============\n" << std::endl;
    }
}
int main()
{
    //Shape s;
    //Shape *p = new Shape();
    //Circle c;       
    //c.draw();   //Statically Bound
    
    //Shape *ptr = new Circle();
    //ptr->draw();    //Dynamically Bound
    //ptr->rotate();  //Dynamically Bound
    Shape *s1 = new Line();
    Shape *s2 = new Square();
    Shape *s3 =  new Circle();
    
    std::vector <Shape *> shapes {s1,s2,s3};
 //   for(const auto s:shapes)
 //   {
 //       s->draw();
 //       s->rotate();
 //       std::cout << "\n===============\n" << std::endl;
 //   }
    
    screen_refresh(shapes);
   // delete ptr;
    delete s1;
    delete s2;
    delete s3;
	return 0;
}
op:
=====
Drawing a Line
Rotateing a Line

===============

Drawing a Square
Rotateing a Square

===============

Drawing a Circle
Rotateing a Circle

===============

Destroying Line
Destroying Shape
Destroying Square
Destroying Shape
Destroying Circle
Destroying Shape

======================================================================================================================================================
															Abstract classes as interface
															==============================
-An abstract class which has only pure virtual functions.
-Provides as public.
-Each subclass is free to implement these services as needed.
-Every method should be implemented in the subclass.
-The service type information is strictly enforced.
-In c++ we use abstract classess with pure virtual functions to acheive the concept of interface.

An Printable Example:
======================
class Printable{
	friend std::ostream &operator<<(std::ostream &os,const Printable &obj );
public:
	virtual void print(ostream &os) const = 0;
	virtual ~Printable(){};
	. . .
};

std::ostream &operator<<(std::ostream &os,const Printable &obj)
{
	obj.print(os);		//This will dynamically binds the print() function whatever object passed to "Printable" &obj
	return(os);
}

class Any_Class : Printable{		//"Any_Class" is derived from "Printable"
public:
	virtual void print(ostream &os) override{	//overriding print() of base class "Printable"
		os << "Hi From Any class";
	}
	. . .
};

Any_Class *ptr = new Any_Class();
cout << ptr << endl;				//"Hi From Any class"

void function1(Any_class &obj)
{
	cout << obj << endl;			////"Hi From Any class"
}

void function2(Printable &obj)		//"Any_Class" IS-A "Printable"
{
	cout << obj << endl;			////"Hi From Any class"
}

function1(*ptr);					//Hi From Any Class
function2(*ptr);					//Hi From Any Class