																Exception Handling
																==================
What is Exception Handling:
=============================
-Dealing with extra ordinary situations.(Dependend upon application and designer)
-Indicates that an extraordinary situation has been detected or has occured.
-Program can deal with the extraordinary situations in suitable manner.


What causes exceptions?
==========================
-Insufficient resources.(Out of memory and no external source)
-Missing resources.(Open and read a file but the file does not exists.)
-Invalid operations.
-range violations.
-underflows and overflows.
-Illegal data and many others.


Exception Safe:
================
-Our program should set for exception safe when our code handles exceptions.

Terminology:
=================
-Exception:
-------------
-An object or primitive(int,double or boolean) that signals that an error has occured.

-Throwing an exception(Raising an exception):
----------------------------------------------
-Your code detects that an error has occured.
-The place where the error occured may not know how to handle the error.
-Code can throw an exception describing the error to another part of the program that knows how to handle the error.


Catching an exception:
------------------------
-code that handles the exception.
-may or may not cause the program to terminate.

C++ syntax:
================
throw:
-------
-Throws an exception.
-Followed by an argument.

try{Code that may throw an exception.}:
------------------------------------------
-You place code that may throw an exception in a try block.
-If the code throw an exception then the try block is exited.
-The thrown exception is handled by catch handler.
-if no catch handler exists then the program terminates.

catch(Exception ex){code to handle the exception}:
--------------------------------------------------
-code that handles exception.
-can have multiple catch handlers.
-may or may not cause the program to terminate.

Divide by zero example:
=========================
double average {};
try{						//try block
	if(total == 0)
	 throw 0;				//throw exception
	average = sum / total;	//Won't execute if total == 0
	//use average here
	 
}
catch(int &ex){				//exception handler
	std::cerr<<"Can't divide by zero" << std::endl;
}

std::cout << Program continues << std::endl;

Throwing an exception from function:
======================================

double calculate_avg(int sum, int total){
	return static_cast<double>(sum)/total;
}

Throw an exception if we can't complete successfully:
-------------------------------------------------------
double calculate_avg(int sum, int total){
	if(total == 0)
		throw 0;
	return static_cast<double>(sum)/total;
}

Catching an exception thrown from a function

double average{};

try{
	average =  calculate_avg(sum,total);
	std::cout<< average << std::endl;
}
catch(int &ex)
{
	std::cerr<<"You can't divide by zero" << std::endl;
}

===================================================================================================================================================
														Stack unwinding in Exception Handling
														=====================================
If an exception thrown but not caught in the current scope c++ tries to find handler for exception by unwinding the stack.

-Function in which the exception was not caught terminates and is removed from the call stack.
-If a try block was used then catch blocks are checked for a match.
-If a no try block was used or catch handler doesn't match stack unwinding occurs again.
-If the stack unwound back to main and no catch handler handles the exception the program terminates.

-When a function is removed or poped from the stack.
-----------------------------------------------------
-All of its local variables are destroyed.
-This means for the local object destructor's are called.
-If we have to free memory with delete then this statement may not executes at all and then it will lead to leak memory.
-This makes it critical that you implement class that requires resources as RAII classes.
-Make sure you clean up your resources in your destructor since you never know when they are going to be called and you do not want to leak any memory or
 leak files and resource in ustable states.
 
======================================================================================================================================================
														User defined exceptions
														========================
We can create exception classes and throw instances of those classes.

Best prctice:
===========
-Throw an object not a primitive type.
-Throw an object by value.
-catch an object by reference(or const reference)

class DivideByZeroException{
};

class NegativeValueException{
};

Throwing User Defined exception class:
--------------------------------------
double calculate_mpg(int miles,int gallons)
{
	if(gallons == 0)
		throw DivideByZeroException();
	if((miles < 0)||(gallons < 0))
		throw NegativeValueException();
	return static_cast<double>miles/gallons;
}


Catching User Defined exceptions:
------------------------------------
try{
	miles_per_gallon = calculate_mpg(miles,gallons);
	std::cout<<miles_per_gallon<<std::endl;
}
catch(const DivideByZeroException &ex){
	std::cerr << "You Can't Divide by Zero" <<std::endl;
}
catch(const NegativeValueException &ex){
	std::cerr<< "Negative Values are not allowed" << std::endl;
}
std::cout << "Bye" << std::endl;

=======================================================================================================================================================
													Class-level Exceptions:
													=======================
Exceptions can also thrown from within a class.

-Methods:
===========
-They works as same way they do for functions as we have seen.
Constructor:
=============
-Constructors may fail.
-Constructors do not return any value.
-Throw an exception from constructor if you can not initialize an object.
-Suppose you are allocating memory dynamically and you are unable to allocate it.
-Or If you open a file in constructor but the file does not exist.
-In case one of these constructor can throw an exception.

Destructor:
===========
-Do not throw an exception from your Destructor.


Class Level Exception:
======================
Account::Account(std::string name, double balance)
	:name{name},balance{balance}{
	if(balance < 0.0)
		throw IllegalBalanceException{};
}

try{
	std::unique_ptr<Account>moes_Account = 
		std::make_unique<Checking_Account>("Moe",-10.0);
}

catch(const IllegalBalanceException &ex){
	std::cerr<<"Could not create Account"<<std::endl;
}
=======================================================================================================================================================-
												The c++ std::exception class hirerchy
												=========================================
The c++ standard library class hirerchy:
=========================================
-C++ provides a class hirerchy of exception classes.
-std::exception is the base class.
-all sub classes implements what() virtual function.
-We can create our own user-defined subclasses.

virtual const char *what() const noexcept;----->returns c - style string that returns description of execption that has occured.

Deriving our subclass from class exception:
============================================
class IllegalBalanceException:public std::exception{
public:
	IllegalBalanceException() noexcept = default;
	~IllegalBalanceException() = default;
	
	virtual const char *what() const noexcept{
		return "Illegal Balance Exception";
	}
	
};

Notes:
======
noexcept------>the method would not throw any exception, Don't throw exceptions from these methods.


