															Opearator Overloading
															---------------------
-Allows user defined types to behave similar to built-in types.
-Using traditional operators such as +,-,=,* with user defined types.
	e.g: 
	----
	+ is used for adding two data types of either integer,double or float etc. traditionally. Using Operator overloading concept we can
    define behaviour like add 2 class object or add 2 srings(Appending 2 strings using +) etc.
	
-Following Operators can not be overloaded.
	::
	:?
	.*
	.
	sizeof

Basic rules:
============
-Precedence and associavity can't be changed.
-"arity" can't be changed(e.g +,-,*,/ are binary which means 2 operand required can't change to 1 operand)
-can't overload opertor's for primitive types(e.g:int,double, etc.)
-Can't create new operators.
-[],(),->,= must be declared as member method of a class.
-other operators can be declared as member method or global functions.

Examples of Operator Overloading:(Operators on User defined types)
=======================================
std::string
------------
s1 = s2+s3
S1 < S2
std::cout << S1

Mystring:
-----------
s1 = s2+s3
s1 < s2
s1 == s2
std::cout << s1;

Player:
---------
Player P1,P2;
P1 < P2;---------------------Might be comparing the health attributes using operator overloading.
p1 == p2;--------------------Might be comparing name,health and XP or some of them using opertaor overloading.(Comparing attributes usng operators)
std::cout << p1;-------------Overloading stream insertion operator to insert player object into stream.


-Assignment operators overloading:
=======================================
Mystring S1 {"FRANK"};
Mystring S2 = S1;//----------------->NOT Assignment
                 //----------------->Same as S2{S1}
S2 = S1;//-------------------------->Assignment as S2 previously created and initialized in the previous statement.

-Assignment occurs if object is initilized previously and you want to assign another object to it
-in C++ '=' invokes copy constructor(Shallow Copy) by default.
-Behaviour of  assignment '=' is memberwise assignment.(Shallow Copy)
-If we have raw pointer in our class then we will overload the assignment operator(=) to do the deep copy to avoid the shallow copy.

Overloading the Copy assignment operator(deep copy):
========================================================
						Type &Type::operator=(const Type &rhs);
						
Example:
---------
Mystring &Mystring::Operator=(const Mystring &rhs);

S2 = S1 //This will assign S2 to S1
	|
	|
	|Same as
   \|/
S2.operator=(S1) //operator= method is called.


Overloaded assignment operator Function:
=========================================
Mystring &Mystring::Operator=(const Mystring &rhs)
{
	if(this == &rhs)// object in the Left hand side is refered as this and object in the right hand side is reffered as rhs
	{
		return *this;                             //if you are doing p1 = p1 or checking for self assignment
	}
	delete str[];                                 //delete the allocated memory assigned by str from heap or dellocate the storage
	str = new char[std::strlen(rhs.str) + 1];     //Assign the heap memory of length equals to rhs member str length.
	std::strcpy(str,rhs.str);					  //Perform  the copy.
	return *this;
}	


Overloading the '=' Move assignment operator(move semantics or stealing):
==========================================================================	
-This operator overloading works with r-value reference(&&)	and move semantics.
-If we have raw pointer we should overload the move assignment operator for the efficiency.

e.g:
=====
			Mystring S1;
			s1 = Mystring {"Frank"}; //"Frank" is a r-value so move assignment overloading can be used here or if move assignment overloading is not
                                        there then copy assignment overloading will be used by default.
										
										
										
										
Syntax:
=========
			Type &Type::operator=(Type &&rhs);
			
			
			Mystring &Mystring::operator = (Mystring &&rhs)
			{
				---
				---
			}
			
			s1 = Mystring("Joe");//move operator= is getting called.
			s1 = "Frank";		 //move operator= is getting called.
			
			

Overloaded assignment operator Function:(Move assignment operator):
=====================================================================
				Mystring &Mystring::operator = (Mystring &&rhs)
				{
					if(this == &rhs)	//Self-assignment
						return *this; 	//return current object
					
					delete []str;		//dellocate current storage
					str = rhs.str;		//steal the pointer
					
					rhs.str = nullptr;  //null out the rhs object
					return *this;		//return current object
				}
			
			
			
Call Flow for "Mystring a{"Hello"};" without Move assignment operator:
===========================================================================
						Mystring a{"Hello"};-----------------------
									|
									|
									|
									|
									|
						//overloaded Constructor
					1st:Mystring::Mystring(const char *source)---------source = 0x4a5020,"Hello", 
							:str(nullptr){-----------------------------this=0x71fdf8,this.str = 0x0
								--------
								--------
								----------
								----------
								else
								{
									str = new char[std::strlen(source)+1];
									std::strcpy(str,source);------------this.str = 0xab1630"Hello"
								}
						}
									|
									|
									|
									|
									a--->str = 0xab1630"Hello"
						
Call flow for  "a = Mystring{"Holla"}; ":
============================================
				 a = Mystring{"Holla"}; 
								|
								|
								|
								|
								|
								|
			1st:Mystring::Mystring(const char *source)---------source = 0x4a5026---->"Holla"
					:str(nullptr){
					-----
					------
					------
						else
						{
							str = new char[std::strlen(source)+1];
							std::strcpy(str,source);-----------str = 0xab1670------>"Holla"
						}
				}	
								|
								|
								|
								|
								|
								|
								|
								|
				//Copy Assignment
			2nd:Mystring &Mystring::operator =(const Mystring &rhs)-----rhs =@0x71fe00:{str = 0xab1670"Holla"}
				{
					std::cout << "Copy Assignment Operator" << std::endl;
					if(this == &rhs)---------------------------this = 0x71fdf8--str = 0xa1630"Hello"
					{
						return *this;
					}
					delete[] this->str;
					str = new char[std::strlen(rhs.str) + 1];
					std::strcpy(this->str,rhs.str);------------this = 0x71fdf8--str = 0xa1630"Holla"
					return *this;------------------------------this = 0x71fdf8
				}
								|
								|
								|
								|
								|
								a--->str = 0xa1630"Holla"
								
								
Call Flow for "a = "Bonjur"; " without move assignment operator:
=================================================================
					a = "Bonjur"; -----------a---str = 0xa1630"Holla"
						|
						|
						|
					Mystring::Mystring(const char *source)-----------source = 0x4a502c"Bonjur"
						:str(nullptr){-------------------------------this = 0x71fe08,this.str = 0x0
							if(source == nullptr)
							{
								str = new char[1];
								*str = '\0';
							}
							else
							{
								str = new char[std::strlen(source)+1];
								std::strcpy(str,source);--------------this = 0x71fe08, this.str = 0xa1670"Bonjur"
							}
					}
							|
							|
							|
							|
							|
					Mystring &Mystring::operator =(const Mystring &rhs)-----rhs = @0x71fe08:{str = 0xa1670"Bonjur"}, this = 0x71fdf8--str = 0xa1630"Holla"
					{
						std::cout << "Copy Assignment Operator" << std::endl;
						if(this == &rhs)
						{
							return *this;
						}
						delete[] this->str;------------------------------------this = 0x71fdf8---str = 0xa1630"[]\n"-->some garbage
						str = new char[std::strlen(rhs.str) + 1];
						std::strcpy(this->str,rhs.str);------------------------this = 0x71fdf8---str = 0xa1630"Bonjur"
						return *this;------------------------------------------this = 0x71fdf8---str = 0xa1630"Bonjur"
					}
							|
							|
							|
							|
							|
						a---->str = 0xa1630"Bonjur"	
						
						
						
						
------------------------------------------------------------------------------------------------------------------------------------------------
Call Flow for "Mystring a{"Hello"};" with Move assignment operator:
===========================================================================
						Mystring a{"Hello"};-----------------------
									|
									|
									|
									|
									|
						//overloaded Constructor
					1st:Mystring::Mystring(const char *source)---------source = 0x4a5020,"Hello", 
							:str(nullptr){-----------------------------this=0x71fdf8,this.str = 0x0
								--------
								--------
								----------
								----------
								else
								{
									str = new char[std::strlen(source)+1];------this=0x71fdf8,this.str = 0xbd1630
									std::strcpy(str,source);--------------------this=0x71fdf8,this.str = 0xbd1630"Hello"
								}
						}
									|
									|
									|
									|
									a--->str = 0xbd1630"Hello"						
						
Call flow for  "a = Mystring{"Holla"}; " with move assignment operator:
==========================================================================
								a = Mystring{"Holla"};
												|
												|
												|
												|
												|
								Mystring::Mystring(const char *source)-------------source=0x4a5006"Holla"
								:str(nullptr){-------------------------------------this = 0x71fe00,this.str=0x0
									if(source == nullptr)
									{
										str = new char[1];
										*str = '\0';
									}
									else
									{
										str = new char[std::strlen(source)+1];------this = 0x71fe00,this->str = 0xbd1670
										std::strcpy(str,source);--------------------this = 0x71fe00,this->str = 0xbd1670"Holla",source=0x4a5006"Holla"
									}
							}
												|
												|
												|
												|
												|
								Mystring & Mystring::operator=(Mystring &&rhs)----this=0x71fdf8,this->str = 0xbd1630"Hello"////rhs = @0x71fe00:{str = 0xbd1670"Holla"}
								{
									std::cout<<"Move Assignment Operator"<<std::endl;
									if(this == &rhs)
										return *this;
									delete[] this->str;---------------------------this=0x71fdf8,this->str = 0xbd1630"`';"(Garbage value)
									this->str = rhs.str;--------------------------this=0x71fdf8,this->str = 0xbd1670"Holla",rhs = @0x71fe00:{str = 0xbd1670"Holla"}
									rhs.str = nullptr;----------------------------rhs = @0x71fe00:{str = 0x0}
									return *this;---------------------------------this=0x71fdf8,this->str = 0xbd1670"Holla"
								}
												|
												|
												|
												|
												|
											a---->	this=0x71fdf8,this->str = 0xbd1670"Holla"
											
											
Call Flow for "a = "Bonjur"; " with move assignment operator:
=================================================================
								a = "Bonjur"; ---->a = this->str=0xd61670"Holla"
										|
										|
										|
										|
										|
						Mystring::Mystring(const char *source)-----------source=0x4a500c"Bonjur",
							:str(nullptr){-------------------------------this = 0x71fe08, this->str = 0x0
								if(source == nullptr)
								{
									str = new char[1];
									*str = '\0';
								}
								else
								{
									str = new char[std::strlen(source)+1];--------this = 0x71fe08, this->str = 0xd61630"jsk"(garbage)
									std::strcpy(str,source);----------------------this = 0x71fe08, this->str = 0xd61630"Bonjur",source=0x4a500c"Bonjur"
								}
						}
										|
										|
										|
										|
										|
						Mystring & Mystring::operator=(Mystring &&rhs)---------rhs=@0x71fe08:{str=0xd61630"Bonjur"}///this=0x71fdf8,this->str = 0xbd1670"Holla"
						{
							std::cout<<"Move Assignment Operator"<<std::endl;
							if(this == &rhs)
								return *this;
							delete[] this->str;-------------------------------this=0x71fdf8,this->str = 0xbd1670"iospp"(garbage)
							this->str = rhs.str;------------------------------this=0x71fdf8,this->str = 0xd61630"Bonjur",rhs=@0x71fe08:{str=0xd61630"Bonjur"}
							rhs.str = nullptr;--------------------------------rhs=@0x71fe08:{str=0x0}
							return *this;-------------------------------------this=0x71fdf8,this->str = 0xd61630"Bonjur"
						}
										|
										|
										|
										|
									a --> this=0x71fdf8,this->str = 0xd61630"Bonjur"
									
									
									
=====================================================================================================================================================
												Operator Overloading as member methods
												=======================================
Unary operators as member methods:(++,--,-,!)
================================================
Syntax:
--------
							ReturnType Type::operator[OP]();
							
e.g:
----
							Number Number::operator-() const;
							Number Number::operator++();
							Number Number::operator++(int);
							bool Number::operator!() const;
							
							
							Number n1{100};
							Number n2 = -n1;			//n1.operator-()
							n2 = ++n1;                  //n1.operator++()
							n2 = n1++;                  //n1.operator++(int)
							
							
							
Operator- overloading for lowercase conversion:
------------------------------------------------
						Mystring larry1 {"LARRY"};
						Mystring larry2;
						
						larry1.display;				//LARRY
						larry2 = -larry1;			//larry1.operator-()
						
						larry1.display();			//LARRY
						larry2.display();			//larry
						
						
code:
======
						Mystring Mystring::operator-() const{
							char *buff = new char(std::strlen(this->str)+1);
							std::strcpy(buff,this->str);
							for(size_t i=0;i<std::strlen(buff);i++)
							{
								buff[i] = std::tolower(buff[i]);
							}
							Mystring temp{buff};
							delete[] buff;
							return temp;
						}
						
						
						
Binary operator as Member Methods(+,-,==,!=,<,> etc,):
=========================================================
Syntax:
--------
						ReturnType Type::operator[OP](const Type &rhs)
						
e.g:
-------
						Number Number::operator+(const Number &rhs)const;
						Number Number::operator-(const Number &rhs)const;
						bool Number::operator==(const Number &rhs)const;
						bool Number::operator<(const Number &rhs)const;
						
						
						
						Number n1{100},n2{200};
						Number n3 = n1+n2;					//n1.operator+(n2)
						n3 = n1-n2;							//n1.operator-(n2)
						if(n1 == n2);						//n1.operator==(n2)
						
						
						
Operator'==' overloading for Mystring class:
===============================================
						bool Mystring::opeartor==(const Mystring &rhs) const{
							if(!(std::strcmp(this->str,rhs.str)))
								return true;
							else
								return false;
						}
						
						Mystring s1{"Jungle"};
						Mystring s2{"Jungle"};
						if(s1 == s2)			//s1.opeartor==(s2)
						
						
Opearator '+' overloading for Mystring class for concatenation:
===============================================================
						Mystring Mystring::operator+(const Mystring &rhs) const
						{
							ssize_t buff_size = std::strlen(this->str)+std::strlen(rhs.str)+1;
							char *buff = new char[buff_size];
							std::strcpy(buff,this->str);
							std::strcat(buff,rhs.str);
							
							Mystring temp{buff};
							delete[] buff;
							return temp;
						}
						
						
						Mystring s1{"Sunil"};
						Mystring s2{"Sahu"};
						Mystring s3;
						s3 = s1+s2;				//s1.operator(s2)
						
						s3.display()			//sunilsahu:9
						
						Mystring s4 = s1 + " " +s2;  //s1.operator+(" ").operator+(s2)
						s4.display		

						Mystring s5 = "Moe" + "stooges" //"Moe".operator+("stooges")  //ERROR
						
						
						
Operator Overloading as Member Functions Task:
=================================================
Given the provided Money class,  please add the overloaded equality operators == and !=

These overloaded operators should return a bool and should be implemented as member functions.

Given 2 Money objects, consider them to be equal if both the dollars and cents attributes are the same for both objects.

First, add the overloaded operator function declarations to the Money class declaration in Money.h

Second, add the overloaded operator function definitions in Money.cpp	


Money.h:
=============
class Money {
    int dollars;
    int cents;
public:
    Money(int dollars, int cents); 
    Money(int total);

    //----DO NOT MODIFY THE CODE ABOVE THIS LINE----
    //----WRITE YOUR METHOD DECLARATIONS BELOW THIS LINE----
    bool operator==(const Money &rhs) const;
    bool operator!=(const Money &rhs) const;
    
    //----WRITE YOUR METHOD DECLARATIONS ABOVE THIS LINE----
    //----DO NOT MODIFY THE CODE BELOW THIS LINE----
};		

Money.cpp:
===========
bool Money::operator==(const Money &rhs) const
{
    return ((this->dollars == rhs.dollars) && (this->cents == rhs.cents));
}

bool Money::operator!=(const Money &rhs) const
{
    return !((this->dollars == rhs.dollars) && (this->cents == rhs.cents));
}		



=======================================================================================================================================================
												Operator Overloading as non member function or global function
												================================================================
Unary Opearator as global function:(++,--,-.!)
=====================================
Note:
=====
Since these are not member functions to access the private attributes of the class objects we have to implement as friends whenever we want to access
the private members.

Syntax:
-------
					ReturnType operator[OP](Type &obj)
					
					[OP] = ++,--,-,!
					
example:
-----------
					Number opeartor-(const Number &obj);
					Number operator++(Number &obj);			//Pre-increment
					Number operator++(Number &obj,int);		//Post-increment
					bool opeartor!(const Number &obj);
					
					Number n1 {100};
					Number n2 = -n1;						//operator-(n1)
					n2 = ++n1;								//operator++(n1)
					n2 = n1++;								//operator++(n1,int)
					
					
Overloading unary - opeartor to make lowercase to the class char * object using non member function or global function:
---------------------------------------------------------------------------------------------------------------------------
This below function declared as 'friend' function in the class

							Mystring opeartor-(const Mysting &obj)
							{
								char *buff = new char[std::strlen(obj.str)+1]
								std::strcpy(buff,obj.str);
								for(ssize_t i=0; i<strlen(buff); i++)
								{
									buff[i] = std::tolower(buff[i]);
								}
								Mystr temp {buff};
								delete[] buff;
								return temp;
							}
							
							
							
							
							
							
Binary Operators as global functions(+,-,==,!=,<,>, etc.):
==========================================================
Syntax:
-------
							ReturnType operator[OP](const Type &lhs, const Type &rhs)
							[OP] = +,-,==,!=,<,>
							
							
example:
========
							Number oprator+(const Number &lhs, const Number &rhs);
							Number oprator-(const Number &lhs, const Number &rhs);
							bool oprator==(const Number &lhs, const Number &rhs);
							Number oprator<(const Number &lhs, const Number &rhs);
							
							Number n1 {100};
							Number n2 {200};
							Number n3;
							n3 = n1+n2;						//operator+(n1,n2)
							n3 = n1-n2;						//operator-(n1,n2)
							if(n1 == n2)					//opeartor==(n1,n2)
							
							
							
Overloading binary == opeartor to check equality between 2 classes:
====================================================================
						bool operator==(const Mystring &lhs,const Mystring &rhs)
						{
							return (std::strcmp(lhs.str,rhs.str) == 0);
						}
						
						
Exercise:
=========

Operator Overloading as Non-member Functions
Given the provided Money class,  please add the overloaded  + operator so that it will add two Money objects together and return a Money object representing their sum.

This overloaded operator should return a Money object and should be implemented as a non-member friend function.

First, add the overloaded operator function declaration to the Money class declaration in Money.h

Second, add the overloaded operator function definition in Money.cpp

This overloaded operator function should not modify the objects in any way.

Money.h:
==========
#ifndef _MONEY_MONEY_H
#define _MONEY_MONEY_H


#include <iostream>

class Money {
    int dollars;
    int cents;
public:
    Money(int dollars, int cents);
    Money(int total);
    int get_dollars() const {return dollars;}
    int get_cents() const {return cents; }
    

    //----DO NOT MODIFY THE CODE ABOVE THIS LINE----
    //----WRITE YOUR METHOD DECLARATIONS BELOW THIS LINE----
    friend Money operator+(const Money &lhs,const Money &rhs);
    
    //----WRITE YOUR METHOD DECLARATIONS ABOVE THIS LINE----
    //----DO NOT MODIFY THE CODE BELOW THIS LINE----
};


#endif //_MONEY_MONEY_H


Money.cpp:
===========
Money operator+(const Money &lhs,const Money &rhs)
{
    int total {0};
    total = (lhs.dollars + rhs.dollars)*100;
    total += lhs.cents + rhs.cents;
    return Money{total};
}

							
=======================================================================================================================================================
													stream insertion and extraction opeartor:(<<,>>)
													============================================
Mystring Larry {"Larry"};
cout << Larry << endl;			//Larry


Player Hero {"Hero", 100, 3};
cout << Hero << endl;			//{name:Hero, health:100, xp:33}


Mystream larry;
cin >> larry;

Player hero;
cin >> hero;

Notes:
========
Overloading insertion and extraction operation doesn't make sense.
-Left operand must be user defined data type if we are doing operator overloading using member function.

Mysting Larry;
larry << cout;    //Normally we do not use insertion operator like this.


stream insertion operator overloading(<<):
=============================================
					std::ostream &opeartor<<(std::ostream &os,const Mystring &rhs)
					{
						os << obj.str;			//if operator<< is a friend function
						//os << obj.get_str();	//if operator<< is a member method
						return os;
					}
					
					
-return a reference to the ostream so we can keep inserting.
-Don't return ostream by value.

stream extraction operator overloading(>>):
=============================================
					std::istream &operator>>(std::istream &is, Mystring &rhs)
					{
						char *buff = new char[1000];
						is >> buff;
						rhs = Mystring {buff};
						delete[] buff;
						return is;
					}


-return a reference to the istream  so we can keep inserting.
-Update the object passed in.




					
						

						

						

						
							
						
						
						
						
						
					

				
			

										
						




