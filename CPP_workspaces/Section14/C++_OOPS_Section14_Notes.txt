															Opearator Overloading
															---------------------
-Allows user defined types to behave similar to built-in types.
-Using traditional operators such as +,-,=,* with user defined types.
	e.g: 
	----
	+ is used for adding two data types of either integer,double or float etc. traditionally. Using Operator overloading concept we can
    define behaviour like add 2 class object or add 2 srings(Appending 2 strings using +) etc.
	
-Following Operators can not be overloaded.
	::
	:?
	.*
	.
	sizeof

Basic rules:
============
-Precedence and associavity can't be changed.
-"arity" can't be changed(e.g +,-,*,/ are binary which means 2 operand required can't change to 1 operand)
-can't overload opertor's for primitive types(e.g:int,double, etc.)
-Can't create new operators.
-[],(),->,= must be declared as member method of a class.
-other operators can be declared as member method or global functions.

Examples of Operator Overloading:(Operators on User defined types)
=======================================
std::string
------------
s1 = s2+s3
S1 < S2
std::cout << S1

Mystring:
-----------
s1 = s2+s3
s1 < s2
s1 == s2
std::cout << s1;

Player:
---------
Player P1,P2;
P1 < P2;---------------------Might be comparing the health attributes using operator overloading.
p1 == p2;--------------------Might be comparing name,health and XP or some of them using opertaor overloading.(Comparing attributes usng operators)
std::cout << p1;-------------Overloading stream insertion operator to insert player object into stream.


-Assignment operators overloading:
=======================================
Mystring S1 {"FRANK"};
Mystring S2 = S1;//----------------->NOT Assignment
                 //----------------->Same as S2{S1}
S2 = S1;//-------------------------->Assignment as S2 previously created and initialized in the previous statement.

-Assignment occurs if object is initilized previously and you want to assign another object to it
-in C++ '=' invokes copy constructor(Shallow Copy) by default.
-Behaviour of  assignment '=' is memberwise assignment.(Shallow Copy)
-If we have raw pointer in our class then we will overload the assignment operator(=) to do the deep copy to avoid the shallow copy.

Overloading the Copy assignment operator(deep copy):
========================================================
						Type &Type::operator=(const Type &rhs);
						
Example:
---------
Mystring &Mystring::Operator=(const Mystring &rhs);

S2 = S1 //This will assign S2 to S1
	|
	|
	|Same as
   \|/
S2.operator=(S1) //operator= method is called.


Overloaded assignment operator Function:
=========================================
Mystring &Mystring::Operator=(const Mystring &rhs)
{
	if(this == &rhs)// object in the Left hand side is refered as this and object in the right hand side is reffered as rhs
	{
		return *this;                             //if you are doing p1 = p1 or checking for self assignment
	}
	delete str[];                                 //delete the allocated memory assigned by str from heap or dellocate the storage
	str = new char[std::strlen(rhs.str) + 1];     //Assign the heap memory of length equals to rhs member str length.
	std::strcpy(str,rhs.str);					  //Perform  the copy.
	return *this;
}	


Overloading the '=' Move assignment operator(move semantics or stealing):
==========================================================================	
-This operator overloading works with r-value reference(&&)	and move semantics.
-If we have raw pointer we should overload the move assignment operator for the efficiency.

e.g:
=====
			Mystring S1;
			s1 = Mystring {"Frank"}; //"Frank" is a r-value so move assignment overloading can be used here or if move assignment overloading is not
                                        there then copy assignment overloading will be used by default.
										
										
										
										
Syntax:
=========
			Type &Type::operator=(Type &&rhs);
			
			
			Mystring &Mystring::operator = (Mystring &&rhs)
			{
				---
				---
			}
			
			s1 = Mystring("Joe");//move operator= is getting called.
			s1 = "Frank";		 //move operator= is getting called.
			
			

Overloaded assignment operator Function:(Move assignment operator):
=====================================================================
				Mystring &Mystring::operator = (Mystring &&rhs)
				{
					if(this == &rhs)	//Self-assignment
						return *this; 	//return current object
					
					delete []str;		//dellocate current storage
					str = rhs.str;		//steal the pointer
					
					rhs.str = nullptr;  //null out the rhs object
					return *this;		//return current object
				}
			
			
			
Call Flow for "Mystring a{"Hello"};" without Move assignment operator:
===========================================================================
						Mystring a{"Hello"};
									|
									|
									|
									|
									|
						//overloaded Constructor
					1st:Mystring::Mystring(const char *source)---------source = 0x4a5020--> "Hello"
							:str(nullptr){
								--------
								--------
								----------
								----------
								else
								{
									str = new char[std::strlen(source)+1];
									std::strcpy(str,source);------------str = 0xab1630--->  "Hello"
								}
						}
									|
									|
									|
									|
									a--->str = 0xab1630--->  "Hello"
						
Call flow for  "a = Mystring{"Holla"}; ":
============================================
				 a = Mystring{"Holla"}; 
								|
								|
								|
								|
								|
								|
			1st:Mystring::Mystring(const char *source)---------source = 0x4a5026---->"Holla"
					:str(nullptr){
					-----
					------
					------
						else
						{
							str = new char[std::strlen(source)+1];
							std::strcpy(str,source);-----------str = 0xab1670------>"Holla"
						}
				}	
								|
								|
								|
								|
								|
								|
								|
								|
				//Copy Assignment
			2nd:Mystring &Mystring::operator =(const Mystring &rhs)-----rhs =@0x71fe00:{str = 0xab1670"Holla"}
				{
					std::cout << "Copy Assignment Operator" << std::endl;
					if(this == &rhs)---------------------------this = 0x71fdf8--str = 0xa1630"Hello"
					{
						return *this;
					}
					delete[] this->str;
					str = new char[std::strlen(rhs.str) + 1];
					std::strcpy(this->str,rhs.str);------------this = 0x71fdf8--str = 0xa1630"Holla"
					return *this;------------------------------this = 0x71fdf8
				}
								|
								|
								|
								|
								|
								a--->str = 0xa1630"Holla"
								
								
Call Flow for "a = "Bonjur"; " without move assignment operator:
=================================================================
					a = "Bonjur"; -----------a---str = 0xa1630"Holla"
						|
						|
						|
					Mystring::Mystring(const char *source)-----------source = 0x4a502c"Bonjur"
						:str(nullptr){-------------------------------this = 0x71fe08,this.str = 0x0
							if(source == nullptr)
							{
								str = new char[1];
								*str = '\0';
							}
							else
							{
								str = new char[std::strlen(source)+1];
								std::strcpy(str,source);--------------this = 0x71fe08, this.str = 0xa1670"Bonjur"
							}
					}
							|
							|
							|
							|
							|
					Mystring &Mystring::operator =(const Mystring &rhs)-----rhs = @0x71fe08:{str = 0xa1670"Bonjur"}, this = 0x71fdf8--str = 0xa1630"Holla"
					{
						std::cout << "Copy Assignment Operator" << std::endl;
						if(this == &rhs)
						{
							return *this;
						}
						delete[] this->str;------------------------------------this = 0x71fdf8---str = 0xa1630"[]\n"-->some garbage
						str = new char[std::strlen(rhs.str) + 1];
						std::strcpy(this->str,rhs.str);------------------------this = 0x71fdf8---str = 0xa1630"Bonjur"
						return *this;------------------------------------------this = 0x71fdf8---str = 0xa1630"Bonjur"
					}
							|
							|
							|
							|
							|
						a---->str = 0xa1630"Bonjur"	
						
						
						
					

				
			

										
						




