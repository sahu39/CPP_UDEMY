																C++_OOPS_Section19_Notes
																==========================
Files, Streams and I/O:
=========================
-C++ uses stream abstraction to work with IO devices.
-Stream is an interface that is independent of actual device.
-C++ uses streams as an interface between the program and input and output devices.
-Independent of actual devices.
-Sequence of bytes.
-For programmer's perceptive we can code to this stream interface and not worry what devices connect to this interface.
-Input streams provides data to the program.
-Output streams receives data from the program.

common header files;
======================
iostream-------------Provides definitions for formatted input and output from/to streams.
fstream--------------Provides definitions for formatted input and output from/to file streams.
iomanip--------------Provides definitions for manipulators used format stream I/O

Commonly used stream classes:
================================
ios------------Provides basic supports for formatted and unformatted I/Ooperations,
iftream--------Provides high level input operations on file based streams.
ofstream-------Provides high level ouptput operations on file based streams.
fstream--------Provides high level I/O operations on file based streams Derived from ofstream & ifstream
stringstream---Provides for high level I/O operations on memory based strings Derived from istringstream ans ostringstream 

Global Stream objects:
=======================
cin-Standard Input stream-by default connected to standard input device(keyboard)--Instance of istream
cout-Standard Output stream-by default connected to standard output device(console)--Instance of ostream
cerr-Standard error stream-by default connected to standard error device(console)--Instance of ostream (unbuffered)
cerr-Standard log stream-by default connected to standard log device(console)--Instance of ostream (unbuffered)

========================================================================================================================================================
Stream Manipualtors:
===================
-Streams have useful member functions to control formatting.
-Can be used on input and output streams.
-The time of the effect on the stream varies.
-Can be used as member functions or as manipulato
	std::cout.width(10);			//Member Function
	std::cout << std::setw(10)		//Manipualtor

Common Stream Manipualtor:
-------------------------
-Boolean:
-----------
		-boolalpha, noboolalpha
-Integer:
---------
		-dec,hex,oct,showbase,noshowbase,showpos,noshowpos,uppercase,nouppercase
-Floating point:
-----------------
		-fixed,scientific,setprecission,showpoint,noshowpoint,showpos,noshowpos
-Filed,width,justification,and fill:
--------------------------------------
		-setw,left,right,internall,setfill
-others:
-------
		-endl,flush,skipws,noskipws,ws
		
========================================================================================================================================================
													Stream Operators(Boolean)
													=========================
-Default when display booleans values is 1 and 0.
-Sometimes the strings true or false are more appropriate.
				
				std::cout << std::boolalpha;
				
				std::cout << (10==10) << std::endl;
				std::cout << (10==20) << std::endl;
				
				will display
				true
				false
				
				std::cout << std::noboolalpha; //1 or 0
				
				
Method version:
----------------
std::cout.self(std::ios::boolalpha);
std::cout.self(std::ios::noboolalpha);

Reset to default:
-------------------
std::cout<<std::resetiosflags(std::ios::boolalpha);

				
				
=======================================================================================================================================================
												Formatting Integer Types:
												============================
-Default when displaying integer values is:
	-dec(base 10)
	-noshowbase - prefix used to show hexadecimal or octal
	-nouppercase - when displaying a prefix and hex values it will be lower case.
	-noshowpos - no '+' is displayed for possitive number.
-These manipulatirs effects all further output to the stream.

Formatting Integer(Different bases):
=====================================
			int num {255};
			std::cout<< std::dec << num << std::endl;
			std::cout<< std::hex << num << std::endl;
			std::cout<< std::oct << num << std::endl;
			
			//will display
			255
			3f
			377
			
			std::cout<< std::showbase;//std::shownobase
			std::cout<< std::dec << num << std::endl;
			std::cout<< std::hex << num << std::endl;
			std::cout<< std::oct << num << std::endl;
			
			//will display
			255
			0x3f
			0377

			
===================================================================================
												File Stream an I/O
												==================
input files(fstream and ifstream)
=================================
ftstream and istream --- used for input files

1.#include <fstream>
2.Declare an fstream or istream object.
3.Connect it to a file in your file system(open it for reading)
4.Read data from the file via stream.(Read by character,Read in binary mode, Read by line, We can use getline,extraction for read)
5.Close the file.

Opening a file or reading with(fstream):
========================================
std::fstream in_file {"../my_file.txt",std::ios::in};//2nd parameter tells open the file in input mode

-Open file for reading in binary mode:
----------------------------------------------
std::fstream in_file {"../my_file.txt",std::ios::in | std::ios::binary};//2nd parameter tells open the file in input mode

Opening a file for reading with (ifstream):
============================================
std::ifstream in_file {"../my_file.txt",std::ios::in};
std::ifstream in_file {"../my_file.txt"};

//Both the above statement means same
-Open file for reading in binary mode:
----------------------------------------------
std::ifstream in_file {"../my_file.txt",std::ios::binary};//2nd parameter tells open the file in input mode

-Open file when user gives the input file name:
===============================================
std::ifstream in_file;
std::string filename;
std::cin >> filename; //get the file name

in_file.open(filename);
//or
in_file.open(filename, std::ios::binary);



Check if file is opened successfully:
=====================================
if(in_file.is_open())
{
	//read from the file
}else{
	//file could not be opened
	//Does it exist
	//should the program terminate?
}

Check if file is opened successfully:(Just Check the object)
=====================================
if(in_file)
{
	//read from the file
}else{
	//file could not be opened
	//Does it exist
	//should the program terminate?
}

Closing the file:
==================
in_file.close();

Reading from file using(>>)(stream extraction operator):
=========================================================
-We can use the extarction operator for the formatted read.
-Same way  we used it with cin.

e.g:
----
100
255.67
Larry

int num {};
double total {};
std::string name {};


in_file >> num;
in_file >> total >> name;

Reading from file using getline:
================================
test.txt:
----------
This is a line

std::string line {};
std::getline(in_file, line);

Reading text file one line at time:
===================================
1st:
---
std::ifstream in_file{"../my_file.txt"};//open file
std::string line{};

if(!in_file){  //Check if file is open
	std::cerr << "File open error" << std::endl;
	return 1;;
}

while(!in_file.eof())			//while not at the end
{
	std::getline(in_file, line);//read a line
	std::cout << line << std::endl;//display the line
}

in_file.close();//close the file
			

2nd:
---
std::ifstream in_file{"../my_file.txt"};//open file
std::string line{};

if(!in_file){  //Check if file is open
	std::cerr << "File open error" << std::endl;
	return 1;;
}

while(std::getline(in_file, line))			//read a line
{
	//std::getline(in_file, line);//read a line
	std::cout << line << std::endl;//display the line
}

in_file.close();//close the file			

Reading text file one character at a time(get):
-----------------------------------------------
std::ifstream in_file{"../my_file.txt"};//open file
char c;

if(!in_file){  //Check if file is open
	std::cerr << "File open error" << std::endl;
	return 1;;
}

while(in_file.get(c))			//read a character
{
	//std::getline(in_file, line);//read a line
	std::cout << c //display the character
}

in_file.close();//close the file			


=======================================================================
							Field width,align and fill
							==========================
Default when displaying floating point values:
=============================================
setw:not set by default
left:when no field width, right: when using field width
fill:not set by default - blan space is used.

Some of these manipulators affect only the next data element put on the stream.


Deafults:
=========

double num{1234.5678};
std::string hello{"Hello"};

std::out << num << hello << std::endl;

//op:
1234.57Hello//Float has 6 digit precission.


double num{1234.5678};
std::string hello{"Hello"};

std::cout << num << std::endl;
std::cout << hello << std::endl;

//op:
1234.57//Float has 6 digit precission.
Hello

Field width-setw:
=================
e.g 1:
-------
double num{1234.5678};
std::string hello{"Hello"};

std::cout << std::setw(10) << num
          << hello << std::endl;
//Here setw will only applied to the next data item 'num' with default justification right it will not effect for item 'hello'
//op:num is displayed right justified with widht 10 with default justification right
123456789012345678901234567890
   1234.57Hello


e.g 2:
-------
double num{1234.5678};
std::string hello{"Hello"};

std::cout << std::setw(10) << num
          << std::setw(10) << hello 
		  << std::setw(10) << hello << std::endl;
//Here setw will applied to the next data item 'num' & 'hello' with default justification right.
//op:num & hello is displayed right justified with widht 10 with default justification right
123456789012345678901234567890
   1234.57     Hello     Hello

Field width-setw & justification:
================================
e.g 1:
--------
double num{1234.5678};
std::string hello{"Hello"};

std::cout << std::setw(10)
          << std::left
		  << num	//only effects num
		  << hello << std::endl;

//op:num is left justified with field width of 10
123456789012345678901234567890
1234.57   Hello

e.g 2:
------
double num{1234.5678};
std::string hello{"Hello"};

std::cout << std::setw(10) << num
          << std::setw(10) << std::right << hello 
		  << std::setw(15) << std::right << hello << std::endl;
//Here setw will applied to the next data item 'num' & 'hello' with default justification right.
//op:
//num is displayed with width 10 with default justification right 
//hello is displayed with right justification with width 10
//hello is displayed with right justification with width 15

1234567890123456789012345678901234567890
   1234.57     Hello          Hello

Filling fixed width - setfill:
==============================
e.g 1:
------
double num {1234.5678};
std::string hello {"Hello"};

std::cout << std::setfill('-');
std::cout << std::setw(10) << num
          << hello << std::endl;

//op:setfill('-') will apply only to next data item 'num' not to 'hello'
//num is displayed with right justified with field width 10 and remaining spaces will be filled with '-'
123456789012345678901234567890
---1234.57Hello



e.g 2:
------
double num {1234.5678};
std::string hello {"Hello"};

std::cout << std::setfill('*');
std::cout << std::setw(10) << num
          << std::setfill('-') << std::setw(10) << hello 
		  << std::setw(15)<< hello 
		  << std::endl;

//op:setfill('*') will apply only to next data item 'num'
//setfill('-') will apply to both data item hello as it is persistent blank spaces for the 2nd item 'hello' is also filled with '-' 
//num is displayed with right justified with field width 10 and remaining spaces will be filled with '-'
//The 1st hello is displayed with right justified with field width 10 and remaining spaces will be filled with '-'
//The 2nd hello is displayed with right justified with field width 10 and remaining spaces will be filled with '-'
1234567890123456789012345678901234567890
***1234.57-----Hello----------Hello

