														Inheritance:
														============
What is Inheritance:
================
-Provides a method for creating new classes from existing class.
-The new class contains data and behaviours of existing class.
-Allows reuses of existing class.
-Allows new classes to modify behaviours of existing classes to make it unique.
	.without modifying existing class
	
Example Related class:
==========================
Banking Application:
-------------------
	-Account----------------------balance,deposit,withdraw
	-Saving Accounts--------------balance,deposit,withdraw,interest rate
	-Checking Accounts.-----------balance,deposit,withdraw,minimum balance,per check fee
	-Trust Accounts.--------------balance,deposit,withdraw,interest rate
	
	
Accounts with inheritance code use:
=====================================
class Account{
	//balance,deposit,withdraw;
};

class Saving_Account : public Account{
	//interest_rate, specialized_withdraw;
};

class Checking_Account : public Account{
	//minimum balance, per check fee, specialized_withdraw;
};

class Trust_Account : public Account{
	//interest_rate, specialized_withdraw,..;
};




	
Graphic Application:
======================
	-Shape
	-Line
	-Oval
	-Circle
	-Square
	-etc.
	
	
Terminology and notation:
=============================
Inheritance:
------------
Process of creating a new clss from a existing class.
Allows reuses of existing class
Single inheritance:
--------------------
A new class is created from anothe 'single' class.

Multiple Inheritance:
-----------------------
A new class is created from two (or more) other classes.



Base class(Parent Class, Super Class):
-----------------------------------------
-The class being extended or inherited from.

Derived class(child class, sub class):
-----------------------------------------
-The class being created form sub class.
-Will inherit attributes and operations from Base class.

"IS-A" relationship:
==========================
-public Inheritance.
-Derived classes are sub type of base class.
-Can use a derived class object whenever we use a base class object.

Inheritance vs composition:
============================
-Public inheritance:
------------------------
-"IS-A" relationship.
-Employee(Derived/Child) "IS-A" person(Base/Parent).
-Checking_Account "IS-A" Account.
-Circle "IS-A" Shape.

-Composition:
----------------
-Creates a "has-a" relationship between classes.
-Person "has-a" Account.
-Player "has-a" Special attack.
-Circle "has-a" Location.

class Person{
	std::string name;	//"has-a" name
	Account account;	//"has-a" Account
};


===========================================================================================================================================
												Deriving classes from existing classes
												======================================
class Base{
	//base class members
};

class Derived:access specifier Base{
	//Derived class members
};

Access-specifiers can be public,private or protected

Access Specifiers:
----------------------
public:
--------
	-Most Common
	-Establishes "IS-A" relationship between base and derived class.
	
private and protected:
----------------------
	-Establishes "derived class "has-a"  base class" relationship.
	
	
Inheritance protected members and class access:
--------------------------------------------------
Protected member class access specifier:
--------------------------------------------
class Base{
	protected:
		//protected base class member

};

-Accessible from Base class itself
-Accessible classes derived from base.
-Not accessible by objects of base(parent) or derived(child)


The protected class member modifier:
-----------------------------------
class Base{
	public:
		int a;	//public base class members
	
	protected:
		int b;  //protected base class members
		
	private:
		int c;	//private base class member
};

Access with public inheritance:
----------------------------------
Base Class																			derived class
-----------																			--------------
public:a																			public:a
protected:b                          public inheritance                             protected:b
private:c																			c: no access



Access with protected inheritance:
----------------------------------
Base Class																			derived class
-----------																			--------------
public:a																			protected:a
protected:b                          protected inheritance                          protected:b
private:c																			c: no access


Access with private inheritance:
----------------------------------
Base Class																			derived class
-----------																			--------------
public:a																			private:a
protected:b                          private inheritance                            private:b
private:c																			c: no access


=================================================================================================================================================
											Constructor and Destructor in inheritance
											==============================================
-A derived class inherits from its base class.
-The base part of the derived class must be initialized before the derived class is initialized.
-When Derived object is created 
	1st.Base class constructor is executed.
	2nd.Derived class constructor is executed.
-
Constructors and class initilization:
-------------------------------------------
class Base{
public:
	Base(){cout << "Base Constructor" << endl;}
};

class Derived:public Base{
public:
	Derived(){cout << "Derived Constructor" << endl;}
};


																				OUTPUT
																				------
Base base;																		Base Constructor




Derived d;																		Base Constructor
																				Derived Constructor	



Destructor:
----------------
-Class Destructors are invoked in the reverse order as constructors.
-The derived class of the Derived class must br destroyed before the base class destructor is invoked.
-When a derived object is destroyed
	1st.Derived class destructor is executed.
	2nd.Base class destructor is executed.
	3rd.Each destructor should free resources allocates in it's own constructors.
	
class Base{
public:
	Base(){cout << "Base Constructor" << endl;}
	~Base(){cout << "Base Destructor" << endl;}
};

class Derived:public Base{
public:
	Derived(){cout << "Derived Constructor" << endl;}
	~Derived(){cout << "Derived Destructor" << endl;}
};



																				OUTPUT
																				------
Base base;																		Base Constructor
																				Base Destructor



Derived d;																		Base Constructor
																				Derived Constructor
																				Derived Destructor
																				Base Destructor
																				
-Derived class does not inherit:
----------------------------------
-Base class constructor
-Base class destructor.
-Base class overloaded assignment operators.
-Base class friend functions.

-However the derived class constructors,destructors, and overloaded assignment operators can invoke the base class versions.
-explicit inheritance of 'non-special' constructors(overloaded constructors)
	using base::base
	
	
========================================================================================================================================================
													Passing arguments to base class constructors:
													====================================================
-To control exactly which base class constructor is used during initilization.
-We can invoke the whichever base class constructor during in the list derived class constructor.
	
example:
-------------
class Base{
private:
    int val;
public:
    Base():val{0}{cout << "Base no-arg constructor" << endl;}
    Base(int x):val{x}{cout << "Base (int) overloaded constructor" << endl;}
    ~Base(){cout << "Base destructor" << endl;}
};

class Derived:public Base{
private:
    int doubled_val;
public:
    Derived()
        :Base{},doubled_val{0}
    {
        cout << "Derived no-arg constructor" << endl;
    }
    Derived(int x)
        :Base{x},doubled_val{x*2}
    {
        cout << "Derived (int) overloaded constructor" << endl;
    }
    ~Derived(){cout << "Derived destructor" << endl;}
};
int main()
{
	//Derived d;
    Derived d{100};
	return 0;
}

op:
------
Base (int) overloaded constructor
Derived (int) overloaded constructor
Derived destructor
Base destructor

====================================================================================================================================================
															copy/move constructors and operator = with derived class
															============================================================
-Not Automatically inherited form Base class.
-We can explicitly invoke the Base class versions from the Derived class.

Copy constructor:
-----------------
-Can invoke copy constructor explicitly
	-Derived object 'other' will be sliced.()
-If we are copying a derived object then we have to make sure base part is also getting copied.
Syntax:
----------
Derived::Derived(const Derived &other)
		:Base(other),{Derived initilization list}
{
	//code
}

-We have a "is-a" inheritance.
-So Derived is a Base.
-Since Derived is a base so we can pass a derived to a method that expects a Base.
-In this case the compiler uses slicing and slices out the Base part of a Derived object.
-In this case we are copying Base part of the Derived object.

example:
----------
class Base{
	int value;
public:
	Base(const Base &other):value{other.value}{
		cout << "Base Copy Constructor" << endl;
	}
};

class Derived:public Base{
	int doubled_value;
public:
	Derived(const Derived &other)
		:Base(other),doubled_value{other.doubled_value}{
		cout << "Derived Copy Constructor" << endl;
	}
};


	

overloaded operator=:
-------------------------
class Base{
	int value;
public:
	Base &operator=(const Base &rhs)
	{
		if(this != &rhs)
			value = rhs.value;
		return *this;
	}
};



class Derived{
	int doubled_value;
public:
	Derived &operator=(const Derived &rhs)
	{
		if(this != &rhs){
			Base::operator=(rhs);
			doubled_value = rhs.doubled_value;
		}
		
		return *this;
	}
};


Notes:
-------
copy/move constructors and overloaded operator=
-often you do not provide your own.

-If you do not defined them in derived
	-Then the compiler will create them automatically and call the base class version's.
	
-If you do provide derived verisons.
	-Then you must invoke the Base class versions explicitly yourself.
	
code example:
-------------	
#include <iostream>
using namespace std;

class Base{
private:
    int val;
public:
    Base():val{0}{cout << "Base no-arg constructor" << endl;}
    Base(int x):val{x}{cout << "Base (int) overloaded constructor" << endl;}
    Base(const Base &rhs)
        :val{rhs.val}
    {
        cout <<"Base Copy Constructor" << endl;
    }
    //Overloaded operator=
    Base &operator=(const Base &rhs)
    {
        if(this != &rhs)
        {
            this->val = rhs.val;
        }
        return *this;
    }
    ~Base(){cout << "Base destructor" << endl;}
};

class Derived:public Base{
private:
    int doubled_val;
public:
    Derived()
        :Base{},doubled_val{0}
    {
        cout << "Derived no-arg constructor" << endl;
    }
    Derived(int x)
        :Base{x},doubled_val{x*2}
    {
        cout << "Derived (int) overloaded constructor" << endl;
    }
    Derived(const Derived &other)
        :Base(other),doubled_val{other.doubled_val}
    {
        cout << "Derived Copy Constructor" << endl;
    }
    Derived &operator=(const Derived &rhs)
    {
        if(this != &rhs)
        {
            Base::operator =(rhs);
            doubled_val = rhs.doubled_val;
        }
        return *this;
    }
    ~Derived(){cout << "Derived destructor" << endl;}
};

int main()
{
	//Derived d;
    Derived d{100};
    Derived d1{d};
	d = d1;
	return 0;
}


op:
------	
Base (int) overloaded constructor
Derived (int) overloaded constructor
Base Copy Constructor
Derived Copy Constructor
Derived destructor
Base destructor
Derived destructor
Base destructor


Call flow for "d = d1;"
==========================
	1st:d = d1
		  |
		  |
		  |
		  |
	2nd:Derived &operator=(const Derived &rhs)
		{
			if(this != &rhs)
			{
				Base::operator =(rhs);

		}
					|
					|
					|
					|
	3rd:Base &operator=(const Base &rhs)
		{
			if(this != &rhs)
			{
				this->val = rhs.val;
			}
			return *this;
		}
	4th:Derived &operator=(const Derived &rhs)
		{
			if(this != &rhs)
			{
            ---
			--
				doubled_val = rhs.doubled_val;
			}
			return *this;
		}
	
===========================================================================================================================================================
													Using and Redesigning Base class Methods(Function Overriding)
													=============================================================
-Derived class objects can directly invoke Base class methods
-Derived class can override or redefine Base class methods.
-Very powerful in the context of polymorphisim.
-In order to override a base method in Deerived class simple create a method with same name and signature as defined in Base class.

example:
-----------
class Account{
public:
	void deposit(double amount){balance += amount;}
};

class Savings_Account : public Account {
public:
	void deposit(double amount){	//Redefine Base Class Method
		amount += some_interest;
		Account::deposit(amount);	//Invoke call Base class method
	}
};



Static Bindings:
================
-Binding of which method to call(Base method/Derived method) is done at compile time.
	-Default Bindings for c++ is static.
	-Derived class object will use Derived::deposit
	-Base class object will use Base::deposit
	-We can explicitly invoke Base::deposit from Derived::deposit.
	
example of static binding of method calls:
---------------------------------------------
Base b;									
b.deposit(1000.0);						//Base::deposit

Derived d;
d.deposit(1000.0);						//Derived::deposit

Base *ptr = new Derived();
ptr->deposit(1000.0);					//Base::deposit due to static binding.
										//Using Dynamic Binding we will call the Derived::deposit